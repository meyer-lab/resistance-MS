<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marc Creixell" />
  <meta name="author" content="Aaron S. Meyer" />
  <meta name="dcterms.date" content="2021-07-21" />
  <meta name="keywords" content="phosphoproteomics, bioinformatics, clustering, data analysis" />
  <title>Motif-based peptide clustering improves phosphoproteome analysis</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--
  Manubot generated metadata rendered from header-includes-template.html.
  Suggest improvements at https://github.com/manubot/manubot/blob/main/manubot/process/header-includes-template.html
  -->
  <meta name="dc.format" content="text/html" />
  <meta name="dc.title" content="Motif-based peptide clustering improves phosphoproteome analysis" />
  <meta name="citation_title" content="Motif-based peptide clustering improves phosphoproteome analysis" />
  <meta property="og:title" content="Motif-based peptide clustering improves phosphoproteome analysis" />
  <meta property="twitter:title" content="Motif-based peptide clustering improves phosphoproteome analysis" />
  <meta name="dc.date" content="2021-07-21" />
  <meta name="citation_publication_date" content="2021-07-21" />
  <meta name="dc.language" content="en-US" />
  <meta name="citation_language" content="en-US" />
  <meta name="dc.relation.ispartof" content="Manubot" />
  <meta name="dc.publisher" content="Manubot" />
  <meta name="citation_journal_title" content="Manubot" />
  <meta name="citation_technical_report_institution" content="Manubot" />
  <meta name="citation_author" content="Marc Creixell" />
  <meta name="citation_author_institution" content="Department of Bioengineering, University of California, Los Angeles" />
  <meta name="citation_author_orcid" content="0000-0003-3981-934X" />
  <meta name="twitter:creator" content="@mcreixell_" />
  <meta name="citation_author" content="Aaron S. Meyer" />
  <meta name="citation_author_institution" content="Department of Bioengineering, University of California, Los Angeles" />
  <meta name="citation_author_institution" content="Department of Bioinformatics, University of California, Los Angeles" />
  <meta name="citation_author_institution" content="Jonsson Comprehensive Cancer Center, University of California, Los Angeles" />
  <meta name="citation_author_institution" content="Eli and Edythe Broad Center of Regenerative Medicine and Stem Cell Research, University of California, Los Angeles" />
  <meta name="citation_author_orcid" content="0000-0003-4513-1840" />
  <meta name="twitter:creator" content="@aarmey" />
  <link rel="canonical" href="https://meyer-lab.github.io/resistance-MS/" />
  <meta property="og:url" content="https://meyer-lab.github.io/resistance-MS/" />
  <meta property="twitter:url" content="https://meyer-lab.github.io/resistance-MS/" />
  <meta name="citation_fulltext_html_url" content="https://meyer-lab.github.io/resistance-MS/" />
  <meta name="citation_pdf_url" content="https://meyer-lab.github.io/resistance-MS/manuscript.pdf" />
  <link rel="alternate" type="application/pdf" href="https://meyer-lab.github.io/resistance-MS/manuscript.pdf" />
  <link rel="alternate" type="text/html" href="https://meyer-lab.github.io/resistance-MS/v/77ac0361ed0a09de4f119ccf270a534b9d480a81/" />
  <meta name="manubot_html_url_versioned" content="https://meyer-lab.github.io/resistance-MS/v/77ac0361ed0a09de4f119ccf270a534b9d480a81/" />
  <meta name="manubot_pdf_url_versioned" content="https://meyer-lab.github.io/resistance-MS/v/77ac0361ed0a09de4f119ccf270a534b9d480a81/manuscript.pdf" />
  <meta property="og:type" content="article" />
  <meta property="twitter:card" content="summary_large_image" />
  <link rel="icon" type="image/png" sizes="192x192" href="https://manubot.org/favicon-192x192.png" />
  <link rel="mask-icon" href="https://manubot.org/safari-pinned-tab.svg" color="#ad1457" />
  <meta name="theme-color" content="#ad1457" />
  <!-- end Manubot generated metadata -->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Motif-based peptide clustering improves phosphoproteome analysis</h1>
</header>
<p><small><em>
This manuscript
was automatically generated on July 21, 2021.
</em></small></p>
<h2 id="authors">Authors</h2>
<ul>
<li><p><strong>Marc Creixell</strong><br>
ORCID
<a href="https://orcid.org/0000-0003-3981-934X">0000-0003-3981-934X</a>
· Github
<a href="https://github.com/mcreixell">mcreixell</a>
· twitter
<a href="https://twitter.com/mcreixell_">mcreixell_</a><br>
<small>
Department of Bioengineering, University of California, Los Angeles
</small></p></li>
<li><p><strong>Aaron S. Meyer</strong><br>
ORCID
<a href="https://orcid.org/0000-0003-4513-1840">0000-0003-4513-1840</a>
· Github
<a href="https://github.com/aarmey">aarmey</a>
· twitter
<a href="https://twitter.com/aarmey">aarmey</a><br>
<small>
Department of Bioengineering, University of California, Los Angeles; Department of Bioinformatics, University of California, Los Angeles; Jonsson Comprehensive Cancer Center, University of California, Los Angeles; Eli and Edythe Broad Center of Regenerative Medicine and Stem Cell Research, University of California, Los Angeles
</small></p></li>
</ul>
<h2 class="page_break_before" id="abstract">Abstract</h2>
<p>Cell signaling is regulated in part through a network of protein kinases and phosphatases. Dysregulation of kinase signaling is widespread in diseases such as cancer and is readily targetable through inhibitors of kinase enzymatic activity. Mass spectrometry-based analysis of kinase signaling can provide a global view of kinase signaling regulation but making sense of these data is complicated by its stochastic coverage of the proteome, measurement of substrates rather than kinase signaling itself, and the scale of the data collected. Here, we propose a combined data and motif clustering strategy (DDMC) that simultaneously clusters substrate peptides into similarly regulated groups based on their variation within an experiment and their sequence profile. We show that this can help to identify putative upstream kinases and supply more robust clustering. We apply this clustering to large-scale clinical proteomic profiling of lung cancer and identify conserved proteomic signatures of tumorigenicity, genetic mutations, and tumor immune infiltration. We propose that DDMC provides a general and flexible clustering strategy for the analysis of phosphoproteomic data.</p>
<h2 id="summary-points">Summary points</h2>
<ul>
<li>Phosphoproteomic data provides information about both the sequence features and abundance of a peptide</li>
<li>Phosphoproteomic clusters identify signaling dysregulation common to tumors and specific genetic backgrounds</li>
<li>Identified clusters are not limited to pre-existing motifs and are therefore not dependent on prior kinase-substrate characterization</li>
<li>DDMC allows the presence of missing values, a major challenge in large-scale signaling data sets</li>
<li>DDMC provides a general and flexible strategy for phosphoproteomic analysis</li>
</ul>
<h2 id="introduction">Introduction</h2>
<!-- Kinase signaling / phophoproteomics in general -->
<p>Cell signaling networks formed by protein kinases regulate cell fate and behavior through protein phosphorylation <span class="citation" data-cites="1702qWji0">(<a href="#ref-1702qWji0" role="doc-biblioref"><em>1</em></a>)</span>. As such, it is not surprising that kinase dysregulation orchestrates the onset and development of a myriad of diseases, including cancer. Measuring cell signaling by mass spectrometry (MS)-based global phosphoproteomics provides a promising opportunity to direct therapy development <span class="citation" data-cites="D89IOQyu">(<a href="#ref-D89IOQyu" role="doc-biblioref"><em>2</em></a>)</span>, particularly given the accessibility of these signaling changes to drug targeting. Nevertheless, despite the rapid accumulation of large-scale phosphoproteomic clinical data, it is still difficult to identify the signaling events leading to observed proteomic alterations and phenotypic outcomes.</p>
<!-- Current methods to analyze phosphoproteomics -->
<p>One approach to make sense of phosphoproteomic measurements has been to infer the activity of upstream kinases. Previously published methods combine each phosphopeptide with reported kinase-substrate interactions to reconstruct signaling networks. For instance, kinase-substrate enrichment analysis (KSEA) averages the signals of groups of kinase substrates to infer enriched pathways in biological samples <span class="citation" data-cites="5KmfVMCw">(<a href="#ref-5KmfVMCw" role="doc-biblioref"><em>3</em></a>)</span>. Another method, Integrative Inferred Kinase Activity (INKA), infers kinase activity by integrating the scores of two components that compute kinase’s overall and activation loop phosphorylation and the scores of two components that quantify the phosphorylation abundance of all substrates of the same kinase. Kinase-substrate relationships are either experimentally observed on PhosphoSitePlus or predicted by NetworKIN, an algorithm that uses sequence motif and protein-protein network information <span class="citation" data-cites="t6scDoJj f3o81IaL 1CITWSvkw">(<a href="#ref-t6scDoJj" role="doc-biblioref"><em>4</em></a>–<a href="#ref-1CITWSvkw" role="doc-biblioref"><em>6</em></a>)</span>. Finally, Scansite predicts kinase-substrate interactions while identifying the sequence motifs that are recognized by specific modular signaling protein domains using kinase specificity profiles generated from oriented peptide library scanning experiments<span class="citation" data-cites="Su0yt3JY">(<a href="#ref-Su0yt3JY" role="doc-biblioref"><em>7</em></a>)</span>. These methods, sometimes in combination, help to reconstruct signaling pathway activities from phosphoproteomic measurements.</p>
<!-- Limitations of these methods; (1) Kinase prediction bias (2) Data missingness -->
<p>Kinase-substrate inference still provides a limited view of signaling network changes, however. Kinase prediction methods are necessarily dependent on characterized kinase-substrate interactions. Unfortunately, the majority of the phosphoproteome remains largely uncharacterized <span class="citation" data-cites="P0XQ2b0s">(<a href="#ref-P0XQ2b0s" role="doc-biblioref"><em>8</em></a>)</span>. Just 20% of kinases have been shown to phosphorylate 87% of currently annotated substrates and around 80% of kinases have fewer than 20 substrates, with 30% yet to be assigned a single substrate <span class="citation" data-cites="P0XQ2b0s">(<a href="#ref-P0XQ2b0s" role="doc-biblioref"><em>8</em></a>)</span>. Hence, insights generated by computational methods dependent on this unequal distribution of known interactions are less likely to identify understudied protein kinases. An additional major challenge being faced during the analysis of large-scale signaling data is missingness. This is due to two major limitations of discovery-mode multiplexed tandem mass tag (TMT) MS. This technique processes batches of a limited number of samples at a time per experiment while the signaling coverage in each experiment is stochastic. This means that the portion of the phosphoproteome quantified in the samples of different TMT experiments varies <span class="citation" data-cites="4f8G3SbH">(<a href="#ref-4f8G3SbH" role="doc-biblioref"><em>9</em></a>)</span>. Thus, in the resulting data set some phosphosites are observed in particular groups of samples whereas in others are not. Computational tools usually require complete data sets and so a frequent strategy to handle this challenge is either imputing missing values with a representative statistic (e.g. average signal) or throwing out any peptides displaying missing values–at the expense of losing critical information <span class="citation" data-cites="ewa3xhd4 Ggt8FNRS">(<a href="#ref-ewa3xhd4" role="doc-biblioref"><em>10</em></a>, <a href="#ref-Ggt8FNRS" role="doc-biblioref"><em>11</em></a>)</span>. Kinase enrichment and prediction methods are further compromised by this problem. Thus, there is a clear need to develop tailored unbiased computational methods capable of modeling the entirety of the phosphoproteomic data set despite missingness.</p>
<!-- Introucing motifs -->
<p>Widely used clustering methods such as hierarchical or k-means clustering identify signaling nodes by grouping phosphopeptides based on their co-variation. This clustering criterion results in groups of peptides that display similar activation patterns across conditions, but that may be regulated by sets of different upstream kinases. Studies have shown that the residues surrounding phosphorylation sites have had to evolve throughout millions of years to become exquisitely fine-tuned motifs that confer signaling specificity and fidelity <span class="citation" data-cites="DVNheP3U j9eQPfet">(<a href="#ref-DVNheP3U" role="doc-biblioref"><em>12</em></a>, <a href="#ref-j9eQPfet" role="doc-biblioref"><em>13</em></a>)</span>. Clustering based on motif similarity might, therefore, improve model interpretation by facilitating the identification of upstream kinases modulating particular clusters that display conserved sequence motifs. On the other hand, clustering peptides based on sequence distance may result in groups of proteins that, while sharing the same set of upstream kinases, are differently regulated due to context. Thus, combining phosphorylation status and sequence similarity may enable a balanced characterization of the cell signaling state.</p>
<!-- Introduction to paper -->
<p>Here, we present an algorithm, Dual Data and Motif Clustering (DDMC), that probabilistically and simultaneously models both the peptide phosphorylation variation and peptide sequence motifs of peptide clusters to reconstitute cell signaling networks and identify causal interactions (Fig. <a href="#fig:method">1</a>). To test the utility of our method, we analyze the phosphoproteomes of 110 treatment-naïve lung adenocarcinoma (LUAD) tumors and 101 paired normal adjacent tissues (NATs) from the National Cancer Institute (NCI)’s Clinical Proteomic Tumor Analysis Consortium (CPTAC) LUAD study <span class="citation" data-cites="Ggt8FNRS">(<a href="#ref-Ggt8FNRS" role="doc-biblioref"><em>11</em></a>)</span>. We characterize the phosphoproteome of patients by identifying those signaling signatures associated with tumorigenesis, the presence of specific mutations, and tumor immune infiltration. In total, we demonstrate DDMC as a general strategy for improving the analysis of phosphoproteomic surveys.</p>
<h2 id="results">Results</h2>
<h3 id="constructing-an-expectation-maximization-algorithm-tailored-for-clustering-phosphoproteomic-data">Constructing an expectation-maximization algorithm tailored for clustering phosphoproteomic data</h3>
<div id="fig:method" class="fignos">
<figure>
<img src="DDMC_functional_diagram.svg" style="width:100.0%" alt="" /><figcaption><span>Figure 1:</span> <strong>Schematic of the DDMC approach to cluster global signaling data and infer upstream kinases driving phenotypes.</strong> A) DDMC is run to cluster an input phosphoproteomic data set to generate 4 clusters of peptides that show similar sequence motifs and phosphorylation behavior. B) Predictive modeling using clusters allows one to establish assocations between specific clusters and features of interest. C) Putative upstream kinases regulating meaningful clusters can be predicted by computing the distance between a cluster motif and PSPL PSSM. PSSM; Position-specific scoring matrix, PSPL; Position scanning peptide library</figcaption>
</figure>
</div>
<p>MS-based global phosphoproteomic data provides unparalleled coverage when interrogating kinase signaling networks and their therapeutic implications. However, these data also present challenging issues as a consequence of their incomplete and stochastic coverage, high-content but low-sample throughput, and variation in coverage across experiments. In addressing these issues, we recognized that MS measurements provide two pieces of information. The exact site of phosphorylation on a peptide sequence and some measure of abundance within the measured samples. Both of these pieces of information are critical to the overall interpretation of the data.</p>
<p>Based on this observation, we built a mixture model that probabilistically clusters phosphosites based on both their peptide sequence and abundance across samples (Figure <a href="#fig:methodS">S1</a>). In each iteration, DDMC applies an expectation-maximization algorithm to optimize clusters that capture the average features of member sequences and their abundance variation (Figure <a href="#fig:method">1</a>A and <a href="#fig:methodS">S1</a>). Both information sources—DDMC data nad sequence—can be prioritized by a weight parameter. With a weight of 0, DDMC is essentially a Gaussian Mixture Model (GMM) that clusters peptides according to their phosphorylation signal. With a very large weight, DDMC exclusively clusters peptides according to their peptide sequences. Clustering both the sequence and abundance measurements ensures that the resulting clusters are a function of both features, which we hypothesized would provide both more meaningful and robust clusters.</p>
<p>The resulting clustering provides coordinated outputs that can be used in a few different ways. The cluster centers, by virtue of being a summary for the abundance changes of these peptides, can be regressed against phenotypic responses (e.g., cell phenotypes or clinical outcomes) to establish associations between particular clusters and response (Figure <a href="#fig:method">1</a>B). This can help to identify which cluster of peptides drives a certain response. Regression using the clusters instead of each peptide ensures that the model can be developed despite relatively few samples, with minimal loss of information since each peptide within a cluster varies in a similar manner.</p>
<p>In parallel or independently, one can interrogate the resulting Position-Specific Scoring Matrices (PSSMs) to describe the overall sequence features of that cluster. These outputs can be readily compared to other information such as experimentally generated profiles of putative upstream kinases via Position Specific Scanning Libraries (PSPL) <span class="citation" data-cites="jW9Cwxfq R5sdZXm8 h7XI6XcI wUjaVTmV gYP9Gpwi">(<a href="#ref-jW9Cwxfq" role="doc-biblioref"><em>14</em></a>–<a href="#ref-gYP9Gpwi" role="doc-biblioref"><em>18</em></a>)</span>. We extracted a collection of 62 kinase specificity profiles to identify which cluster motifs most resemble the optimal motif of putative upstream kinases (Figure <a href="#fig:method">1</a>C) <span class="citation" data-cites="XkcIGLbK wUjaVTmV gYP9Gpwi">(<a href="#ref-wUjaVTmV" role="doc-biblioref"><em>17</em></a>–<a href="#ref-XkcIGLbK" role="doc-biblioref"><em>19</em></a>)</span>. However, kinase-substrate specificity is also dictated by features outside of the immediate substrate region, we also note that our approach is more general than strictly assembling kinase-substrate predictions as non-enzymatic specificity information may be present in the DDMC sequence motifs. Overall, this overview demonstrates how DDMC can take complex, coordinated signaling measurements and find patterns in the phosphorylation signals to reconstruct signaling networks and associate particular clusters and phenotypes.</p>
<h3 id="dual-data-motif-clustering-strategy-robustly-imputes-missing-values">Dual data-motif clustering strategy robustly imputes missing values</h3>
<div id="fig:missingness" class="fignos">
<figure>
<img src="figureM2.svg" style="width:100.0%" alt="" /><figcaption><span>Figure 2:</span> <strong>Benchmarking the robustness of motif clustering to missing measurements.</strong> A) A schematic of the process for quantifying robustness to missing values. Any peptides containing less than 7 TMT experiments were discarded. For the remaining 15904 peptides, an entire random TMT experiment was removed per peptide and these values were stored for later comparison. Next, these artifical missing values were imputed using either a baseline strategy (peptide mean/minimum signal, constant zero, or matrix completion by PCA) or the corresponding cluster center. Once a mean squared error was computed for each peptide, the second iteration repeats this process by removing a second TMT experiment. A total of 5 random TMT experiments per peptide were imputed by clustering using a different number of clusters (B-E) or different weights (E-I).</figcaption>
</figure>
</div>
<p>A major limitation of multiplexed MS-based large-scale phosphoproteomic data is the presence of missing values due to (i) the limited number of samples proccesed at a time per TMT experiment and (ii) the stochastic signaling coverage in each experiment. Consequently, upon concatenation of the different TMT experiments, many phosphosites are observed in groups of samples. To evaluate the robustness of our combined dual data-motif clustering (DDMC) method in analyzing incomplete data sets, we designed a computational experiment wherein we removed specific observations and predicted them using the cluster centers corresponding to the peptides those missing values belonged to (Figure <a href="#fig:missingness">2</a>A). The resulting mean squared errors between the actual and predicted values were compared to commonly used imputation strategies such as the peptides’ mean or minimum signal, contant zero, or matrix completion by PCA. Furthermore, we evaluated the imputation performance of our method when clustering the data using a different number of clusters. We observed that increasing the number of clusters improved the imputation of missing values (Figure <a href="#fig:missingness">2</a>B-F). Additionally, we performed the same experiment by clustering the data with different weights. Interestingly, weight selection barely affected imputation performance, indicating that cluster centers based on sequence only imputed missing values as accurately as when using the phosphorylation signal (Figure <a href="#fig:missingness">2</a>F-I). These results indicate that DDMC clearly outperforms standard imputation strategies such as using constant zero or the peptides’ mean or minimum signal, and imputes missing values as accurately as matrix completion by PCA.</p>
<h3 id="ddmc-correctly-predicts-akt1-and-erk2-as-upstream-kinases-of-signaling-clusters-containing-their-substrates">DDMC correctly predicts AKT1 and ERK2 as upstream kinases of signaling clusters containing their substrates</h3>
<div id="fig:val" class="fignos">
<figure>
<img src="figureM3.svg" style="width:100.0%" alt="" /><figcaption><span>Figure 3:</span> <strong>Validation of upstream kinase predictions.</strong> (A-B) PCA analysis of the DDMC phosphoproteome clusters of MCF7 cells subjected to a drug screen <span class="citation" data-cites="1CAsv2YaF">(<a href="#ref-1CAsv2YaF" role="doc-biblioref"><em>20</em></a>)</span>. C) Heatmap showing the effect of inhibitors on the phosphorylation signal of cluster 1. D) DDMC upstream kinase prediction of cluster 1. E) NetPhorest upstream kinase prediction of cluster 1. (F) Resulting PSSM generated using ERK2 substrates reported by Carlson et al <span class="citation" data-cites="HgmaqMVG">(<a href="#ref-HgmaqMVG" role="doc-biblioref"><em>21</em></a>)</span>. (G) Upstream kinase predictions of CPTAC clusters 7, 9, 13, and 21 in addition to the ERK2 motif shown in (F). H) Upstream kinase predcitions of the same PSSMs after randomly shuffling the motif positions.</figcaption>
</figure>
</div>
<!-- AKT cluster via MCF7 drug screening -->
<p>DDMC is a tailored method that clusters MS-generated phosphosites using its phosphorylation behavior and sequence information. A major benefit of modeling the sequence information is the construction of cluster motifs which can be useful to infer what putative upstream kinases might preferentially target peptides of a specific cluster. To validate the ability of our model to make upstream kinase predictions, we used DDMC to cluster the phospohproteomic measurements of MCF7 cells treated with a panel of 61 drug inhibitors reported by Hijazi et al <span class="citation" data-cites="1CAsv2YaF">(<a href="#ref-1CAsv2YaF" role="doc-biblioref"><em>20</em></a>)</span>. PCA analysis of the resulting cluster centers clearly identified an inverse correlation between the scores of AKT/mTOR targeted inhibitors and the loading of cluster 1, indicating that the cluster’s overall signal is downregulated by the presence of these compounds (Figures <a href="#fig:val">3</a>A-B). Additional inhibitors targeting PDK1, FLT3, and S6K also negatively correlated with cluster 1. Since the authors’ kinase-inhibitor selectivity screen indicate that these compounds did not decrease neither AKT1 nor mTOR activity, these results indicate that PDK1, FLT3, and S6K might partially modulate cluster 1. A heatmap displaying cluster’s 1 phosphorylation signal across treatments corroborates that these peptides are dramatically downreagulated when treated with AKT/mTOR/PIK3 inhibitors (Figure <a href="#fig:val">3</a>C). Encouragingly, The specificity profile of AKT—within a collection of 55 different kinase PSPL matrices—most closely matches the PSSM of cluster 1 (Figure <a href="#fig:val">3</a>D). Additionally, NetPhorest identified AKT as the second top scoring upstream kinase of cluster 1, further corroborating DDMC’s prediction.</p>
<!-- ERK2 substrates -->
<p>Next, we extracted the sequences of ERK2 substrates identified in Carlson et al to create an ‘artificial’ ERK2-specific PSSM positive control (ERK2+ motif) (Figure <a href="#fig:val">3</a>F). As expected, ERK2 was predicted to be the upstream kinase with the highest preference for the cluster’s motif (Figure <a href="#fig:val">3</a>G). As an additional test, the consistent enrichment of hydrophobic and polar residues throughout the entire ERK2 target motif (Figure <a href="#fig:val">3</a>F), we asked whether randomly shuffling all cluster PSSM positions surrounding the phosphoacceptor residue would affect the upstream kinase prediction. Interestingly, this experiment led to a 2-fold increase in the distance between ERK2 specificity profile and the ERK2+ motif (Figures <a href="#fig:val">3</a>G and H). We subjected those clusters from the CPTAC data set that were preferentially favored by ERK2 to the same experiment. As expected, we observed a similar decline in specificity between the clusters PSSMs and ERK2 PSPL matrix (Figures <a href="#fig:val">3</a>H). Note that the noticeable difference in prediction between the ERK2+ motif and the CTPAC ERK2 motifs is not surprising given that while the former group contains only 26 peptides, the CPTAC clusters contain ~500-2000 phosphosites. Overall, this experiment generally shows that despite the homogenous biophysical properties of ERK2 target motif across positions, the relative enrichment of hydrophobic and polar residues in each position determines the extent to which ERK2 favors a particular motif (Figures <a href="#fig:val">3</a>G and H). Altogether, these results illustrate two different scenarios in which the average features of member sequences can be used to successfully identify upstream kinases regulating clusters.</p>
<h3 id="a-dual-data-motif-strategy-improves-prediction-of-different-phenotypes-and-provides-more-robust-clustering">A dual data-motif strategy improves prediction of different phenotypes and provides more robust clustering</h3>
<div id="fig:preds" class="fignos">
<figure>
<img src="figureM4.svg" style="width:100.0%" alt="" /><figcaption><span>Figure 4:</span> <strong>Sequence information enhances model prediction and provides more robust clustering.</strong> A) Performance of a regression model predicting the mutational status of STK11 (blue) EGFR and/or ALK (yellow) and tumor infiltration (green) in LUAD patients using either only phosphorylation data (weight=0), mainly sequence information (50), or both (0 &lt; w &lt; 50). B) MSE between the phosphorylation signal of 2000 randomly selected peptides and the center of its assigned clusters using a weight of 0 (data), 20 (mix), or 50 (sequence). C) Cumulative PSSM enrichment across positions comparing the data, mix, and sequence clustering strategies. (D-H) TBC1D5 peptide p-signal MSE (D), cumulative PSSM enrichment (E), and PSSM logo plots (F-H).</figcaption>
</figure>
</div>
<!-- Intro to model set up and data -->
<p>As shown later in this study (Figures <a href="#fig:TvsNAT">5</a>, <a href="#fig:STK11">6</a>, <a href="#fig:TI">7</a>), we utilized DDMC to analyze the phosphoproteomes of 110 treatment-naïve LUAD tumors and 101 paired normal adjacent tissues (NATs) from the NCI’s CPTAC LUAD study. We used DDMC with the binomial sequence distance method and 24 clusters (Figure <a href="#fig:method">1</a>, <a href="#fig:missingness">2</a>B). We were able to include 30,561 peptides that were not observed in every tumor through our ability to handle missing data, but still filtered out 11,822 peptides that were not captured in at least two 10-plex TMT runs. We used this fitting result throughout the rest of this study. The resulting 24 cluster motifs can be found in Figure <a href="#fig:motifsS">S2</a>.</p>
<!-- Predictions -->
<p>To evaluate the benefit of incorporating the peptide sequence information into the clustering criterion, we asked whether utilizing DDMC with different sequence weights would affect the performance of a regularized logistic regression model that predicts the mutational status of STK11, whether a patient harbors a mutation in EGFR and/or a gene fusion in ALK (EGFRm/ALKf), and the level of tumor infiltration (“Hot” versus “Cold”). We found that for all three phenotypes, when the method only uses the phosphorylation signal (weight=0), the patient samples tend to be classified with less accuracy compared with when a combination of both data and sequence is used. Interestingly, in the case of STK11, the use of the largest weight wherein mainly the sequence motifs are used for clustering provided the best prediction performance. Likewise, EGFRm/ALKf samples were best classified with a mix weight of 15 or 50. Finally, the regression model classifying whether a sample is “hot-tumor-enriched” (HTE) or “cold-tumor-enriched” (CTE) showed the best fitness with a weights of 10, 35, and 40. Together, these results indicate that observing the motif information during clustering leads to final clusters that enhance the performance of downstream phenotype prediction models (Figures <a href="#fig:preds">4</a>A and <a href="#fig:predsS">S3</a>).</p>
<!-- Model behavior -->
<p>Next, we explored how using different weights affects the overall phosphorylation signal and sequence information of the resulting clusters. To do so, we compared the model behavior after clustering the CPTAC data with a weight of 0 (data only), 20 (mix), and 50 (mainly sequence). First, we hypothesized that the data model would generate clusters wherein its members would show less variation in phosphorylation signal and thus a lower mean squared error (MSE). To test this, we computed the average peptide-to-cluster MSE of 2000 randomly selected peptides for each model across all clusters. Although the differences were not significant, we did observe a direct correlation between weight and MSE (Figure <a href="#fig:preds">4</a>B). Next, we calculated the cumulative PSSM enrichment by summing the sequence information (bits) of all cluster PSSMs per model. As expected, increasing the weight led to a proportional increment in cumulative sequence information (Figure <a href="#fig:preds">4</a>C). To further illustrate the clustering behavior, we tracked the phosphosite TBC1D5 S584-p in the three models. Consistent with the general trend, the Data and Mix models generated lower p-signal MSE when compared to its cluster center than the Sequence model whereas weight correlated with the total PSSM enrichment (Figures <a href="#fig:preds">4</a>D-E). Next, we quantified whether in addition to an increase in absolute enrichment, the Mix and Sequence models generated more similar cluster motifs to TBC1D5 S584-p sequence than the Data model. To do so, we computed the mean of all pairwise PAM250 scores between the query sequence and all cluster sequences across models which clearly confirmed that as the sequence prioritization of the model increases, the cluster PSSM is not only more enriched across all positions but also displays a more representative sequence of TBC1D5 phosphosite (Figures <a href="#fig:preds">4</a>F-I). These results conclusively show that using a mixed weight that similarly prioritizes both information sources—data and sequence—leads to more robust clustering of phosphosites displaying similar phosphorylation behavior and sequence motifs.</p>
<h3 id="widespread-dramatic-signaling-differences-between-tumor-and-normal-adjascent-tissue">Widespread, dramatic signaling differences between tumor and normal adjascent tissue</h3>
<div id="fig:TvsNAT" class="fignos">
<figure>
<img src="figureM5.svg" style="width:100.0%" alt="" /><figcaption><span>Figure 5:</span> <strong>Conserved tumor differences compared to normal adjascent tissue.</strong> A) Hierarchical clustering of DDMC cluster centers. B–C) Principal components analysis scores (B) and loadings (C) of the samples and phosphopeptide clusters, respectively. D) Phosphorylation signal of tumor and NAT samples per cluster and statistical significance according to a Mann Whitney rank test (* = p-value &lt; 0.05 and ** = p-value &lt; 0.001). E) Receiver operating characteristic curve (ROC) of a regularized logistic regression model. F) Logistic regression weights per cluster. G) Upstream kinase predictions of clusters 11 and 12. (H) NetPhorest kinase predictions of cluster 12. (I-J) Gene ontology analysis and (K-L) representative peptides of enriched biological processes of clusters 11 and 12.</figcaption>
</figure>
</div>
<!-- The signaling in both tissues is so different that any modeling strategy captures distinct patterns -->
<p>We explored whether DDMC could recognize conserved signaling patterns in tumors compared to normal adjacent tissue (NAT). The signaling difference between tumors and NAT samples was substantial, highlighting the significant signaling rewiring that tumor cells must undergo (Figure <a href="#fig:TvsNAT">5</a>A). Using principal components analysis, we could observe that NAT samples were more similar to one another than to each tumor sample (Figure <a href="#fig:TvsNAT">5</a>B/C). Nearly every cluster was significantly different in its average abundance between tumor and NAT (Figure <a href="#fig:TvsNAT">5</a>D). Not surprisingly given these enormous differences, samples could be almost perfectly classified using their phosphopeptide signatures, with or without DDMC (Figure <a href="#fig:TvsNAT">5</a>E; <a href="#fig:TvsNATS">S4</a>). Using the DDMC clusters, a logistic regression model identified that only cluster 11 contributes to the prediction of NAT samples (Figure <a href="#fig:TvsNAT">5</a>C.</p>
<!-- NEK1/2 and ciliagenesis -->
<p>With the abundance changes and regression results we observed, we decided to further explore clusters 11 and 12. Cluster 11 shows a PSSM motif that might be preferred by NEK1, 2, and 4, and an enrichment of peptides involved in gas and oxygen transport, as well as cytoskleleton remodeling or migration-related phenotypes according to a Gene Ontology (GO) analysis (Figures <a href="#fig:TvsNAT">5</a>G and I). Even though NEKs are a largely understudied family of serine/threonine kinases, NEK1/2 have an established role in the formation and disassembly of cilia and NEK4 has also been implicated in regulating microtubule dynamics and stability <span class="citation" data-cites="ZIstAG1r 1563Ps2iZ">(<a href="#ref-ZIstAG1r" role="doc-biblioref"><em>22</em></a>, <a href="#ref-1563Ps2iZ" role="doc-biblioref"><em>23</em></a>)</span>. The primary cilium serves as a signaling hub via the local expression of cell surface receptors and signaling molecules to sense environmental stimuli and thus regulate a handful of phenotypes including adaptation to hypoxia, migration, and escape from apoptosis <span class="citation" data-cites="frubowLH fWhtbxpo">(<a href="#ref-frubowLH" role="doc-biblioref"><em>24</em></a>, <a href="#ref-fWhtbxpo" role="doc-biblioref"><em>25</em></a>)</span>. Cancer cells typically lack cilia which could promote the emergence of these malignant phenotypes. Cluster 11 displays a striking phosphorylation decrease in tumor samples compared with NATs which could be representative of the presence or lack of NEK1/2 signaling, respectively. Within this group of peptides, there is a notable overrepresentation of hemoglobin subunits (HBG1, HBD, HBB, and HBA2) which could illustrate the different oxygenation status of NATs versus malignant tissues. Moreover, several cytoskletal-remodeling proteins are present in cluster 11 such as PEAK1, FLNA, GAS2L2, MARCKS, PEAK1, and ARHGEF7. All of these signaling molecules are dramatically downregulated in tumor compared to NAT samples (Figure <a href="#fig:TvsNAT">5</a>K).</p>
<!-- CK2 and DNA damage response -->
<p>On the other hand, CK2 clearly favors the sequence motif of cluster 12 suggesting that this kinase might be a key modulator of this group of peptides (Figure <a href="#fig:TvsNAT">5</a>G). This association is also established by NetPhorest which underscores the presence of multiple experimentally validated CK2 substrates in this cluster (Figure <a href="#fig:TvsNAT">5</a>J). GO analysis of cluster 12 determined a substantial enrichment in negative regulation of DNA duplex unwinding and pre-replicative complex assembly involved in cell cycle DNA replication. (Figures <a href="#fig:TvsNAT">5</a>G, I-J). DNA duplex unwinding and replication are important procssess that play a major role in maintaining genome stability. DNA helicases are the enzymes responsible for unwinding the DNA and thus are essential for DNA replication. As such, they have been widely associated with DNA damage response (DDR) and cancer development <span class="citation" data-cites="aG54kP6W">(<a href="#ref-aG54kP6W" role="doc-biblioref"><em>26</em></a>)</span>. Interestingly, CK2 has been widely implicated in modulating DNA repair signaling pathways in response to DNA damage to promote cell survival in cancer <span class="citation" data-cites="sf0tBKVd 1Bu1guxLX 17QfmaEkN">(<a href="#ref-sf0tBKVd" role="doc-biblioref"><em>27</em></a>–<a href="#ref-17QfmaEkN" role="doc-biblioref"><em>29</em></a>)</span>. In fact, a study found that the CK2 inhibitor CX-4945 blocked DDR induced by gemcitabine and cisplatin and synergizes with these compounds in ovarian cancer cell lines <span class="citation" data-cites="1UIt7EAA">(<a href="#ref-1UIt7EAA" role="doc-biblioref"><em>30</em></a>)</span>. Cluster 12 contains several signaling proteins related to DNA replication and genome stability such as MCM3/4, the p53 interactor TP53BP1, BRCA1, ATRX, CENPF, and CDKs which are strikingly downregulated in NATs and upregulated in tumor samples (Figure <a href="#fig:TvsNAT">5</a>L). These results, therefore, suggest that CK2 might regulate signaling molecules within cluster 12 involved in DNA repair pathways to induce the survival of cancer cells. Taken together, DDMC builds phosphoproteomic clusters that present signaling dysregulation common to tumors compared to NATs and identifies putative upstream kinases modulating them. These features can help to interpret phosphoproteomic results and inform the generation of hypotheses for follow up experiments.</p>
<h3 id="genetic-driver-mutations-are-associated-with-more-targeted-phosphoproteomic-rewiring">Genetic driver mutations are associated with more targeted phosphoproteomic rewiring</h3>
<div id="fig:STK11" class="fignos">
<figure>
<img src="figureM6.svg" style="width:100.0%" alt="" /><figcaption><span>Figure 6:</span> <strong>Phosphoproteomic aberrations associated with STK11 mutational status.</strong> A) Phosphorylation signal of STK11 WT and mutant samples per cluster and statistical significance according to a Mann-Whitney rank test (* = p-value &lt; 0.05 and ** = p-value &lt; 0.001). B) ROC of a logistic regression model predicting the STK11 mutational status and (C) its corresponding weights per sample type. (D) Putative upstream kinases of clusters 7, and 8. (E) Representative cohesin loading peptides in cluster 7. (F-G) GO analysis and representative Golgi fragmentation peptides of cluster 8.</figcaption>
</figure>
</div>
<!-- STK11 DDMC data  -->
<p>Inactivating somatic mutations in STK11 lead to increased tumorigenesis and metastasis <span class="citation" data-cites="11bgLfbny">(<a href="#ref-11bgLfbny" role="doc-biblioref"><em>31</em></a>)</span>. Thus, we aimed to identify the phosphoproteomic aberrations triggered by this genetic event. The majority of clusters were significantly altered, generally toward higher abundances with a mutation (Figure <a href="#fig:STK11">6</a>A). The cluster centers corresponding to each patient’s tumor and NAT samples could succesfully predict the STK11 mutational status by regularized logistic regression (Figure <a href="#fig:STK11">6</a>B). The tumor phosphoproteomic signal of cluster 7 greaty contributed to classify mutant STK11 samples, whereas the tumor signal of 8 and 14 helped classify WT STK11 specimens. (Figure <a href="#fig:STK11">6</a>C). These results motivated further exploration of clusters 7 and 8 which present sequence motifs favored by ERK2, CK1/BRCA1/PKD, and PKA/PKC/PKD, respectively (Figure <a href="#fig:STK11">6</a>D).</p>
<!-- ERK2 cohesin loading -->
<p>Cluster 7 is highly enriched with peptides involved in regulation of the cell cycle by cohesin loading (Figure <a href="#fig:STK11">6</a>E). Cohesin is a protein complex that mediates sister chromatid cohesion by directly binding with DNA. This interaction holds both chromatids together after DNA replication until anaphase wherein cohesin is removed to facilitate chromosome segregation during cell division. Cluster 7 contains the inhibitor phosphosite of the tumor suppressor RB1 S795-p, the member of the cohesin loading complex NIPBL (S280-p, S280-p;S284-p, and S350-p), and the cohesin release factor WAPL (S221-p and S221-p;S223-p). Studies have shown that RB1 inactivation can lead to defects in chromosome cohesion that in turn compromises chromosome stability <span class="citation" data-cites="1DOj8GdC6 1TTuawsr">(<a href="#ref-1DOj8GdC6" role="doc-biblioref"><em>32</em></a>, <a href="#ref-1TTuawsr" role="doc-biblioref"><em>33</em></a>)</span>. Manning et al demonstrated that depletion of WAPL in RB1-deficient cells promoted cohesin association with chromatin <span class="citation" data-cites="1TTuawsr">(<a href="#ref-1TTuawsr" role="doc-biblioref"><em>33</em></a>)</span>. Among these phosphosites, we observed strong opposing signals between STK11 WT and mutant patients in NIPBL S280-p, WAPL S221-p;S223-p and RB1 S795-p (Figure <a href="#fig:STK11">6</a>E) which reinforces the association between STK11 activity and chromatin instability. Moreover, CDCA5 is key regulator of sister chromatid cohesion by stabilizing cohesin complex association with chromatin and it was identified as a prognostic factor of lung cancer through a tumor tissue microarray analysis of 262 non–small cell lung cancer (NSCLC) patients <span class="citation" data-cites="M3dxE1vk">(<a href="#ref-M3dxE1vk" role="doc-biblioref"><em>34</em></a>)</span>. Interestingly, they showed that CDCA5 phosphorylation of S209 by ERK2 enhanced cell proliferation <span class="citation" data-cites="M3dxE1vk">(<a href="#ref-M3dxE1vk" role="doc-biblioref"><em>34</em></a>)</span>. Therefore, these results might suggest that mutations inactivating mutations in STK11 might correlate with signaling defects in sister chromatid cohesion during the cell cycle which in turn could lead to chromosome instability and cell cancer growth. In fact, STK11 inactivation has been associted with genomic instability although the signaling mechanism underlying this phenotypic response remains elusive <span class="citation" data-cites="X9fj6E2N">(<a href="#ref-X9fj6E2N" role="doc-biblioref"><em>35</em></a>)</span>.</p>
<!-- CK1 and Golgi coating -->
<p>The signal of phosphosites of cluster 8 specifically in tumor samples largely contributes to predict the signaling differences between STK11 WT and mutant samples (Figure <a href="#fig:STK11">6</a>C). This cluster presents a clear enrichment of peptides involved in the regulation of the Golgi apparatus such as GOLGA2-5, GOLGB1, and GOLPH3 (Figure <a href="#fig:STK11">6</a>F). Cancer cells commonly undergo fragmentation of the Golgi which has been shown to drive several malignant molecular signatures including the hyperactivity of motor proteins and kinase signaling dysregulation <span class="citation" data-cites="dV6PKXoq">(<a href="#ref-dV6PKXoq" role="doc-biblioref"><em>37</em></a>)</span>. Myosin 18A and 1E pertain to cluster 18 and the former has been reported to interact with GOLPH3 to induce Golgi dispersal. Moreover, a series of studies uncovered that GOLPH3 promotes cell proliferation in cancer <span class="citation" data-cites="1GoPZmw6b V6txFd6T SMyQ7lQi">(<a href="#ref-1GoPZmw6b" role="doc-biblioref"><em>38</em></a>–<a href="#ref-SMyQ7lQi" role="doc-biblioref"><em>40</em></a>)</span>. The phosphorylation behavior of GOLPH3, Myosin 18A, and GOLGA2 in STK11 WT compared with STK11 mutant patients shows a dramatic increase of abundance in the latter which supports the association between STK11 activity and an oncogenic role of the Golgi apparatus in these patients (Figure <a href="#fig:STK11">6</a>E). Together, these results suggest that STK11 mutations in tumor samples could affect the dispersion of the Golgi apparatus compared with STK11 WT samples.</p>
<!-- EGFRm/ALKf -->
<p>Tyrosine kinase inihibitors (TKIs) targeting the receptor tyrosine kinases (RTKs) EGFR and ALK are effective treatments in cancer patients with EGFR mutations and/or ALK translocations (EGFRm/ALKf). However, these treatments are limited by drug resistance which in some cases can be mediated by the concomitant signaling of both RTKs activated by driver mutations <span class="citation" data-cites="13s4Fnh0b OFi5gkLd">(<a href="#ref-13s4Fnh0b" role="doc-biblioref"><em>41</em></a>, <a href="#ref-OFi5gkLd" role="doc-biblioref"><em>42</em></a>)</span>. Once again, the signaling cluster centers allowed a regularized logistic regression model to accurately classify samples according to its EGFRm/ALKf status (Figure <a href="#fig:EGFRm/ALKf">S5</a>).</p>
<!-- Comparison to other regression strategies -->
<p>Finally, we compared the classification performance of four regularized logistic regression models fit to either the DDMC clusters, clusters generated by the standard methods GMM and k-means, or the raw phosphoproteomic data directly. It is worth noting that unlike DDMC, methods such as GMM, k-means, or direct regression can not handle missing values and thus for this strategies we used the 1,311 peptides that were observed in all samples, whereas DDMC was fit to the entire data set comprising 30,561 phosphosites. Interestingly, we found that samples were classified with higher accuracy with DDMC than using GMM and similarly than with k-means, especially with STK11 (Figure <a href="#fig:RegressionsS">S6</a>A). Direct regression to the raw signaling data yielded excellent performance, however this strategy assigns thousands of coefficients to different peptides that vary every time the model is run which renders this approach unable to establish a consistent link between mutations and signaling (Figure <a href="#fig:RegressionsS">S6</a>). Our analysis illustrates the association between STK11 activity with two novel phenotypes, namely chromosome cohesion during cell cycle and Golgi fragmentation, and proposes putative signaling mechanisms to support it.</p>
<h3 id="exploration-of-immune-infiltration-associated-signaling-patterns-in-tumors">Exploration of immune infiltration-associated signaling patterns in tumors</h3>
<div id="fig:TI" class="fignos">
<figure>
<img src="figureM7.svg" style="width:100.0%" alt="" /><figcaption><span>Figure 7:</span> <strong>Phosphoproteomic signatures driving tumor immune infiltration.</strong> (A) Phosphorylation abundance of CTE and HTE samples per cluster and statistical significance according to a Mann-Whitney rank test (B-C) ROC and coefficients of a logistic regression model predicting infiltration status—cold-tumor enriched (CTE) vs hot-tumor enriched (HTE)—(D) Putative upstream kinases of clusters 2 and 6 and (E-F) its GO enrichment analysis (G-H) ROC and coefficients of a logistic regression model predicting tumor infiltration with only clusters 21 and 24 (I) Upstream kinases of clusters 21 and 24 and (J-K) GO analysis.</figcaption>
</figure>
</div>
<!-- Intro to immunotherapy in NSCLC -->
<p>Immune checkpoint inhibitors (ICIs) have emerged as effective treatment options for NSCLC patients. However, there still is a need to identify or influence which patients will respond to these therapies. Patients that do not respond to ICIs have tumors that present immune-cold behavior either inherently, or via an adaptive process after long exposure to the drug. However, the signaling mechanism by which malignant cells prevent tumor infiltration remains elusive. To this end, we used our DDMC clusters to explore the shared signaling patterns that differentiate “hot-tumor-enriched” (HTE) from “cold-tumor-enriched” CTE LUAD patients <span class="citation" data-cites="Ggt8FNRS oDPNDPlI">(<a href="#ref-Ggt8FNRS" role="doc-biblioref"><em>11</em></a>, <a href="#ref-oDPNDPlI" role="doc-biblioref"><em>43</em></a>)</span>. HTE and CTE status per patient was determined using xCell by Gilette et al<span class="citation" data-cites="Ggt8FNRS">(<a href="#ref-Ggt8FNRS" role="doc-biblioref"><em>11</em></a>)</span>.</p>
<!-- Data -->
<p>We observed that four clusters were significantly different in their average abundance between HTE and CTE samples (Figure <a href="#fig:TI">7</a>A). Cluster 17, 18, and 20 display significantly higher abundances in HTE compared to CTE samples whereas cluster 21 presents the opposite trend. Samples could be accurately classified using the DDMC clusters (Figure <a href="#fig:TI">7</a>B). This predictive performance was mainly explained by a positive association of cluster 2 with HTE status as well as that of cluster 6 with CTE. Additional clusters contributed to explain the signaling differences between both groups but to a lesser extent (Figure <a href="#fig:TI">7</a>C).</p>
<!-- Interpretation -->
<p>These results prompted us to further investigate clusters 6, 17, 20, and 21 which our model predicts to be regulated by CK1/PKA, STK11/p38, CK2/STK11, and ERK2, respectively (Figure <a href="#fig:TI">7</a>D). When exploring immunologically relevant phenotypes in the GO analysis of each cluster, we observed that clusters 6, 17, and 20 showed a substantial over-representation of immunological processes. Conversely, neither of these were present in the GO analyses of cluster 2 nor cluster 21 wherein the former substantially contributes to predict CTE samples and the latter shows a significant increase of phosphorylation abundance in CTE over HTE samples (Figures <a href="#fig:TI">7</a>A and C). A gene ontology analysis indicates that cluster 6 members are particularly involved in mediating B cell homeostasis, but also T cell differentiation, T cell receptor signaling, and regulation of T cell activation. These processes are modulated, at least in part, by ABL1, LCK, PAK1, and DOCK10/11 which are upregulated in HTE and downregulated in CTE samples (Figures <a href="#fig:TI">7</a>E and H). Cluster 17 gene ontology analysis unveils an over-representation of several innate and adaptive immune response pathways wherein CD44, SDK1, PKC, PLD1, CAPN1 and GSTP1 might be involved. For instance, CD44 is expressed in both endothelial and immune cells and its regulation plays a key role in enabling neutrophil and lymphocyte recruitment into tissues <span class="citation" data-cites="kQ3GsiVA P9l0l2Iw">(<a href="#ref-kQ3GsiVA" role="doc-biblioref"><em>44</em></a>, <a href="#ref-P9l0l2Iw" role="doc-biblioref"><em>45</em></a>)</span> (Figures <a href="#fig:TI">7</a>F and I). A study found that the osteopontin (OPN)/CD44 interaction is an immune checkpoint that controls CD8+ T cell activation and tumor immune evasion in which elevated expression of OPN correlated with decreased patient survival and confered host tummor immune tolerance. Cluster 20 is enriched by responses orchestrated by the innate immune system (Figures <a href="#fig:TI">7</a>G and J). The transcription factor NFATC crucially regulates T cell activation and proliferation and several studies show that the predicted upstream kinase of cluster 20 CK2 directly phosphorylates this protein and regulates its gene expression <span class="citation" data-cites="qkFzZLTE nHwwoaZ0">(<a href="#ref-qkFzZLTE" role="doc-biblioref"><em>46</em></a>, <a href="#ref-nHwwoaZ0" role="doc-biblioref"><em>47</em></a>)</span>. In addition, CK2 has also been shown to phosphorylate Regulators of Calcineurin (RCAN) proteins, which indirectly regulate NFATC function <span class="citation" data-cites="IeA9XieB">(<a href="#ref-IeA9XieB" role="doc-biblioref"><em>48</em></a>)</span>. Multiple peptides of both NFATC and RCAN are members of cluster 20 which reinforces the role of CK2 in promoting immune infiltration in lung cancer patients. Intriguinly, inactivating mutations in STK11 have been reported to promote anti-PD1/PD-L1 resistance in KRAS-mutant LUAD suggesting a key role of STK11 in modulating tumor immune infiltration <span class="citation" data-cites="YLezYGM1">(<a href="#ref-YLezYGM1" role="doc-biblioref"><em>49</em></a>)</span>. All in all, these data demonstrate that the presence or lack of tumor immune infiltration can be accurately predicted by the DDMC clusters which in turn help identify putative upstream kinases modulating immune evasion.</p>
<h2 id="discussion">Discussion</h2>
<!-- Paper Summary / Intro -->
<p>Phosphorylation-based cell signaling through the coordinated activity of protein kinases enables cells to swiftly integrate environmental cues and orchestrate a myriad of biological processes. MS-based global phosphoproteomic data provides the opportunity to interrogate signaling networks to better understand cellular decision-making and its therapeutic implications. However, these data also present challenging issues as a consequence of their incomplete and stochastic coverage, high-content but low-sample throughput, and variation in coverage across experiments. Here, we propose a clustering method, Dual Data and Motif Clustering (DDMC), that untangles highly complex coordinated signaling changes by grouping phosphopeptides based on their phosphorylation behavior and sequence similarity (Figure <a href="#fig:method">1</a>). To test the utility of DDMC, we clustered the phosphoproteomes of LUAD patients and utilized the resulting groups of peptides to decipher signaling dysregulation common to tumors, genetic backgrounds, and tumor infiltration status (Figures <a href="#fig:TvsNAT">5</a>, <a href="#fig:STK11">6</a>, <a href="#fig:TI">7</a>).</p>
<!-- Sequence information improves prediction and interpretation -->
<p>Previous efforts in regressing mass spectrometry-based phosphorylation measurements against phenotypic or clinical data are based on the great ability of certain regression models such as PLSR or LASSO to robustly predict using high-dimensional and correlated data <span class="citation" data-cites="QJFQ9RQQ">(<a href="#ref-QJFQ9RQQ" role="doc-biblioref"><em>50</em></a>)</span>. While these models can generally be predictive with such data, they are not easily interpretable (Figure <a href="#fig:TvsNATS">S4</a>B). Hence, we hypothesized that clustering large-scale MS measurements based on biologically meaningful features and utilizing the cluster centers to fit regression methods could enhance the predictive performance of the model while providing highly interpretable results wherein clusters constitute signaling nodes distinctly correlated with cell patient phenotypes. Here, we demonstrate that DDMC enhances model prediction and interpretation (Figures <a href="#fig:preds">4</a>A, <a href="#fig:RegressionsS">S6</a>, <a href="#fig:val">3</a>).</p>
<!-- Caveats of upstream predictions -->
<p>Model interpretation is enhanced by comparing the resulting cluster PSSMs with kinase specificity data such as PSPL to identify putative upstream kinases modulating signaling clusters. Computational validations showed that DDMC was able to correctly associate AKT1 and ERK2 with clusters of their respective substrates (Figure <a href="#fig:val">3</a>). It is worth noting, however, that kinase specificity is defined by additional features beyond the phosphosite motif such as kinase-substrate co-localization, regulation by phosphosite-binding domains (e.g. SH2, PTB domains), or docking. In addition, a major limitation of PSPL experiments is that since it does not provide docking information, the real affinity between the string of identified peptide residues as key determinants of specificity of a sequence motif and the interacting kinase domain is unknown which could also compromise kinase-cluster associations established by DDMC. A method combining bacterial surface-display of peptide libraries with next-generation sequencing tackles this limitation by quantifying the specificity of a kinase to virtually all possible motif combinations <span class="citation" data-cites="bRPGEQL4">(<a href="#ref-bRPGEQL4" role="doc-biblioref"><em>51</em></a>)</span>. Thus, as the number of profiled kinases with this technique increases, these measurements could be used to rank cluster peptides by magnitude of specificity to a specific kinase to make better upstream kinase predictions.</p>
<!-- Data-driven strategy -->
<p>Importantly, the identified clusters are not limited to pre-existing motifs and are therefore not dependent on prior experimentally validated kinase-substrate interactions. Thereby, this method could improve our understanding of the signaling effects of understudied kinases. For instance, our model predicts NEK1&amp;2 to modulate, at least in part, a cluster that presents a dramatic increase in signaling in NATs compared to tumors. After further exploration of this cluster this leads us to hypothesize that the lack of NEK signaling in tumor samples might associated with the absence of ciliagenesis and adaptation to hypoxia in lung tumors <a href="#fig:TvsNAT">5</a>G-H). Additionally, we show that cluster 8, which greatly contributes to explain the signaling differences between STK11 WT and mutant samples in tumors (Figure <a href="#fig:STK11">6</a>C), is enriched with proteins such as GOLPH3 and Myosin 18A that have been shown to regulate Golgi fragmentation in cancer <span class="citation" data-cites="1GoPZmw6b V6txFd6T SMyQ7lQi">(<a href="#ref-1GoPZmw6b" role="doc-biblioref"><em>38</em></a>–<a href="#ref-SMyQ7lQi" role="doc-biblioref"><em>40</em></a>)</span>. This prompts us to consider the novel interaction between CK1 and these signaling molecules.</p>
<!-- Modeling missingness -->
<p>Moreover, an additional major challenge being faced during the analysis of large-scale signaling data is missingness. Given that statistical tools require complete data sets, researchers use standard methods to impute missing values such as the peptides’ mean or minimum signal, constant zero, or PCA imputation only in peptides wherein at least 50% of their samples were required to have non-missing values as excessive missing values can result in poor imputation <span class="citation" data-cites="Ggt8FNRS ewa3xhd4 dbN6HcER">(<a href="#ref-ewa3xhd4" role="doc-biblioref"><em>10</em></a>, <a href="#ref-Ggt8FNRS" role="doc-biblioref"><em>11</em></a>, <a href="#ref-dbN6HcER" role="doc-biblioref"><em>52</em></a>)</span>. In this study we show that DDMC can model a data set of 30,561 peptides after filtering out any phosphosites that were not captured in at least 2 TMT (up to ~80% of missingness) by ignoring unobserved values during EM distribution estimation and calculation of GMM probabilities (see methods). Therefore, this method enables clustering of signaling data despite a remarkable amount of missing values. This important feature could offer the possibility of conducting pan-cancer phosphoproteomics studies using readily available large-scale clinical phosphoproteomic data.</p>
<!-- Models combining info in models -->
<p>The benefit of building algorithms combining different information sources to build better models is also shown in previously published approaches. For instance, INKA predicts active kinases by integrating two scores illustrating the a kinase’s activation status accordingo to its phosphorylation status, and two scores that quantify the abundance of its substrates <span class="citation" data-cites="12p8KTQaG">(<a href="#ref-12p8KTQaG" role="doc-biblioref"><em>53</em></a>)</span>. In another study, Exarchos et al. formulated a decision support system that integrates clinical, imaging, and genomic data to identify the factors that contribute to oral cancer progression and predict relapses. The authors found that combining the more accurate individual predictors yielded better predictions than those generated by other strategies reported in the literature <span class="citation" data-cites="1AT5pt9hP">(<a href="#ref-1AT5pt9hP" role="doc-biblioref"><em>54</em></a>)</span>. Additionally, BOADICEA is a method that allows systematic risk stratification of breast cancer patients by incorporating the effects of lifestyle, hormonal and reproducrive risk factors, mammographic density, and of the common breast cancer susceptibility genetic variants into the prediction model.</p>
<!-- Conclusion / Closure -->
<p>In total, in this study we show that combining the information about the sequence features and phosphorylation abundance leads to more robust clustering of global signaling measurements. Moreover, subsequent use of DDMC cluster to regress against cell phenotypes led to enhanced model predictions and interpretation. Thus, we propose DDMC as a general and flexible strategy for phosphoproteomic analysis.</p>
<h2 id="materials-and-methods">Materials and Methods</h2>
<p>All analysis was implemented in Python v3.9 and can be found at <a href="https://github.com/meyer-lab/resistance-MS" class="uri">https://github.com/meyer-lab/resistance-MS</a>.</p>
<h3 id="expectation-maximization-em-algorithm-architecture">Expectation-maximization (EM) algorithm architecture</h3>
<p>We constructed a modified mixture model that clusters peptides based on both their abundance across conditions and their peptide sequence. The model is defined by a given number of clusters and weighting factor to prioritize either the data or the sequence information. Fitting was performed using expectation-maximization, initialized at a starting point. The starting point was derived from k-means clustering the abundance data after missing values were imputed by PCA with a component number equal to the number of clusters. During the expectation (E) step, the algorithm calculates the probability of each peptide being assigned to each cluster. In the maximization (M) step, each cluster’s distributions are fit using the weighted cluster assignments. The peptide sequence and abundance assignments within the E step are combined by taking the sum of the log-likelihood of both assignments. The peptide log-likelihood is multiplied by the user-defined weighting factor immediately before to influence its importance. Both steps repeat until convergence as defined by the increase in model log-likelihood between iterations falling below a user-defined threshold.</p>
<h3 id="phosphorylation-site-abundance-clustering-in-the-presence-of-missing-values">Phosphorylation site abundance clustering in the presence of missing values</h3>
<p>We modeled the log-transformed abundance of each phosphopeptide as following a multivariate Gaussian distribution with diagonal covariance. Each dimension of this distribution represents the abundance of that peptide within a given sample. For example, within a data set of 100 patients and 1000 peptides, using 10 clusters, the data is represented by 10 Gaussian distributions of 100 dimensions. Unobserved/missing values were indicated as NaN and ignored during both distribution estimation and when calculating probabilities. Any peptides that were detected in only one TMT experiment were discarded.</p>
<h3 id="sequence-cluster-comparison">Sequence-cluster comparison</h3>
<h4 id="pam250">PAM250</h4>
<p>During model initialization, the pairwise distance between all peptides in the dataset was calculated using the PAM250 matrix. The mean distance from each peptide to a given cluster could then be calculated by:</p>
<p><span class="math display">\[w=\frac{1}{n} \left(P \cdot v \right)\]</span></p>
<p>Where <span class="math inline">\(P\)</span> is the <span class="math inline">\(n \times n\)</span> distance matrix, <span class="math inline">\(n\)</span> is the number of peptides in the dataset, <span class="math inline">\(v\)</span> is the probability of each peptide being assigned to the cluster of interest, and <span class="math inline">\(w\)</span> is the log-probabilities of cluster assignment.</p>
<h4 id="binomial-enrichment">Binomial enrichment</h4>
<p>We alternatively used a binomial enrichment model for the sequence representation of a cluster based on earlier work <span class="citation" data-cites="tatP35Vj">(<a href="#ref-tatP35Vj" role="doc-biblioref"><em>55</em></a>)</span>. Upon model initialization, a background matrix <span class="math inline">\(G\)</span> was created with a position-specific scoring matrix of all the sequences together. Next, an <span class="math inline">\(i \times j \times k\)</span> data tensor <span class="math inline">\(T\)</span> was created where <span class="math inline">\(i\)</span> is the number of peptides, <span class="math inline">\(j\)</span> is the number of amino acid possibilities, and <span class="math inline">\(k\)</span> is the position relative to the phosphorylation site. This tensor contained 1 where an amino acid was present for that position and peptide, and 0 elsewhere.</p>
<p>Within each iteration, the cluster motif would be updated using <span class="math inline">\(v\)</span>, the probability of each peptide being assigned to the cluster of interest. First, a weighted count for each amino acid and position would be assembled:</p>
<p><span class="math display">\[k = \left(T^\intercal \cdot v \right)^\intercal\]</span></p>
<p>Because peptides can be partially assigned to a cluster, the counts of each amino acid and position can take continuous values. We therefore generalized the binomial distribution to allow continuous values using the regularized incomplete Beta function:</p>
<p><span class="math display">\[M = B \left(\| \vec{v}\|_1 - k, k + 1, 1 - G \right)\]</span></p>
<p>Finally, the log-probabiltiy of membership for each peptide was calculated based on the product of each amino acid-position probability.</p>
<p><span class="math display">\[w = \log (T \times M)\]</span></p>
<p>We confirmed that this provided identical results to a binomial enrichment model for integer counts of amino acids <span class="citation" data-cites="tatP35Vj">(<a href="#ref-tatP35Vj" role="doc-biblioref"><em>55</em></a>)</span>, but allowed for partial assignment of peptides to clusters.</p>
<h3 id="quantifying-the-influence-of-sequence-versus-data">Quantifying the influence of sequence versus data</h3>
<p>The magnitude of the weight used to scale the sequence and data scores is arbitrary. We do know that with a weight of 0 the model only uses the phosphorylation measurements. Alternatively, with an enormously large weight the motif information is prioritized. However, we do not know to what extent each information source is prioritized in general. Therefore, to quantify the relative importance of each type of data, we calculated our clustering results at each weighting extreme, and then calculated the Frobenius norm of the resulting peptide assignments between those and the clustering of interest.</p>
<h3 id="generating-cluster-motifs-and-upstream-kinase-predictions">Generating Cluster Motifs and Upstream Kinase Predictions</h3>
<p>For each cluster we computed a position-specific-scoring matrix (PSSM). To do so, we populated a residue/position matrix with the sum of the corresponding cluster probabilities for every peptide. Thus, for a particular peptide the same probability will be summed to the corresponding residue/position pairs of the resulting matrix. Once all peptides have been observed, the resulting matrix is normalized by averaging the mean probability across amino acids and log2-transformed to generate a PSSM. In parallel, we computed a PSSM including all sequences that served as background to account for the different amino acid occurrences within the data set. Then, we subtracted each cluster PSSM with the background PSSM and limited any large negative numbers to -3. Next, we extracted several kinase specificity profiling results from the literature <span class="citation" data-cites="gYP9Gpwi XkcIGLbK gYP9Gpwi h7XI6XcI">(<a href="#ref-h7XI6XcI" role="doc-biblioref"><em>16</em></a>, <a href="#ref-gYP9Gpwi" role="doc-biblioref"><em>18</em></a>, <a href="#ref-gYP9Gpwi" role="doc-biblioref"><em>18</em></a>, <a href="#ref-XkcIGLbK" role="doc-biblioref"><em>19</em></a>)</span>. The distance between PSSM and PSSL motifs was calculated using by the Frobenius norm of the difference. Motif logo plots were generated using logomaker <span class="citation" data-cites="17tuo8dIX">(<a href="#ref-17tuo8dIX" role="doc-biblioref"><em>56</em></a>)</span>.</p>
<h3 id="evaluate-clustering-by-imputation-of-values">Evaluate clustering by imputation of values</h3>
<p>To evaluate the ability of our model to handle missing values, we removed random, individual TMT experiments for each peptide and used the model to impute these values. The number of missing values per peptide is highly variable. Therefore, in our error quantitation, we stratified peptides by their missingness percentage and computed the average mean squared error between the actual values and predictions—or imputed peptide average—in each group. We calculated the reconstruction error across different combinations of cluster numbers and weights using the same process.</p>
<h3 id="associating-clusters-with-molecular-and-clinical-features">Associating clusters with molecular and clinical features</h3>
<p>To find clusters that tracked with specific molecular or clinical features we implemented two different strategies: logistic regression and hypothesis testing. For binary problems such as Tumor vs NAT samples or mutational status we used l1 regularized logistic regression and Mann-Whitney rank tests. In the former, we tried to predict the feature of interest using the phosphorylation signal of the cluster centers, whereas in the latter, for each cluster we split all patients according to their specific feature and tested whether the difference in the median signal between both groups was statistically different. We performed Bonferroni correction on the p-values computed by the Mann-Whitney tests. Gene ontology analysis was performed using the GENEONTOLOGY software (geneontology.org) <span class="citation" data-cites="IFevKgND 1FmAqWcpa">(<a href="#ref-IFevKgND" role="doc-biblioref"><em>57</em></a>, <a href="#ref-1FmAqWcpa" role="doc-biblioref"><em>58</em></a>)</span>.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>This work was supported by NIH U01-CA215709 to A.S.M. and in part by the UCLA Jonsson Comprehensive Cancer Center (JCCC) grant NIH P30-CA016042.</p>
<h2 id="author-contributions-statement">Author contributions statement</h2>
<p>A.S.M. conceived the project. Both authors performed the analysis. Both authors wrote the manuscript.</p>
<h2 class="page_break_before" id="supplementary-figures">Supplementary Figures</h2>
<h3 id="sequence-modeling">Sequence Modeling</h3>
<p>DDMC simultaneously models phosphorylation signal and peptide sequence to cluster global signaling measurements. The user-defined variables of this algorithm are the number of clusters and the scaling factor or weight to prioritize the data or the sequence scores. During the Expectation– or E-step, the algorithm guesses a data and a sequence probability distribution given the current model parameters to assign every peptide into a cluster based on its maximum likelihood estimation. That is, the GMM generates the probabilities of each phosphosite being assigned to every cluster according to its log-transformed abundance. In the PAM250 method, the average distance between a peptide’s sequence and each of those within a cluster are calculated using the transition matrix. For the binomial method, we collected 333,492 random MS-generated phosphopeptides from the public compendium PhosphoSitePlus13 to be used as the set of background sequences. The probability of observing each amino acid at each position was calculated by comparing each cluster and the background using an incomplete beta function. First, the cluster sequences are used to build counts matrices displaying the number of amino acid occurrences across positions. These matrices are then individually compared to the weighted frequencies matrix of the background set of sequences using a binomially distributed model in order to generate a binomial probability matrix for each cluster. The probability of a peptide being assigned to any cluster is the average of each position’s probability present in the correspondinog cluster’s binomial probability matrix. For each cluster, the final score is the sum of the GMM and sequence scores multiplied by a user-defined weight which scales both scores so that a weight of 0 or a very large number only scores the data or sequence, respectively. Importantly, the final scores represent the relative probabilities that define the partial membership of the query peptide to each cluster. In other words, the EM algorithm provides soft cluster assignments for every peptide. Then, the GMM parameters and cluster sequences are updated during the M-step based on the assignments generated during the previous E-step. These two steps repeat until convergence.</p>
<div id="fig:methodS" class="fignos">
<figure>
<img src="EM_diagram.svg" data-tag="S1" alt="" /><figcaption><span>Figure S1:</span> <strong>Schematic of the DDMC simultaneous data and peptide sequence clustering approach.</strong> Peptides are initialized into clusters at random. The measurements of abundance are represented by a multivariate Gaussian mixture model where each dimension of the distribution represents the abundance within a sample. Next, an expectation-maximization fitting scheme is used. During the expectation step, the distance of each peptide sequence to each cluster is calculated. This is done either through a binomial enrichment scheme (method 1) or using the average PAM250 distance (method 2). In parallel, the distance of each peptide abundance is compared to the cluster centers. These two distances are combined to update the assignments of each peptide to each cluster. During the maximization step, the cluster centers of the data are updated based on the weighted average of the peptide abundances in each condition. The peptide motifs are similarly updated through a weighted combination of the assigned peptides. Both steps continue sequentially until the change in peptide assignments between each iteration drops below a threshold.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="logo-plots-of-all-cluster-motifs">Logo plots of all Cluster Motifs</h3>
<div id="fig:motifsS" class="fignos">
<figure>
<img src="figureMS2.svg" data-tag="S2" alt="" /><figcaption><span>Figure S2:</span> <strong>Logo plots of all Cluster PSSMs.</strong> (A-U) Sequence motifs of clusters 1 through 24.</figcaption>
</figure>
</div>
<h3 id="a-dual-data-motif-strategy-improves-prediction-of-different-phenotypes">A dual data-motif strategy improves prediction of different phenotypes</h3>
<div id="fig:predsS" class="fignos">
<figure>
<img src="figureMS3.svg" data-tag="S3" alt="" /><figcaption><span>Figure S3:</span> <strong>Sequence information enhances model prediction</strong> (A-O) Performance of a regression model predicting the mutational status of STK11 (A-E) EGFR and/or ALK (F-J) and tumor infiltration level (hot versus cold) (K-O) in LUAD patients using either only phosphorylation data (0), mainly peptide sequences (50), or a mix (15, 20, 40). EGFRm/ALKf; EGFR mutant and/or ALK fusion.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="implementing-different-modeling-strategies-to-find-tumor-differences-compared-to-nats">Implementing different modeling strategies to find tumor differences compared to NATs</h3>
<div id="fig:TvsNATS" class="fignos">
<figure>
<img src="figureMS4.svg" data-tag="S4" alt="" /><figcaption><span>Figure S4:</span> <strong>Additional modeling strategies to find conserved tumor differences compared to NATs</strong> A) ROC plot of a logistic regression model fit to the complete portion of the phosphoproteomic CPTAC LUAD data set. B) Phospho-peptides with largest weights explaining the observed differences between tumors and NATs. C-D) ROC plot of a logistic regression model fit to the complete portion of the signaling data set clustered by k-means (D) and its corresponding cluester coefficients (D). E) p-site abundance between NAT and tumor patients per k-means cluster and its statistical significance. (F-H) Analysis using GMM clustering.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="regressing-ddmc-clusters-against-the-mutational-status-of-egfralk">Regressing DDMC clusters against the mutational status of EGFR/ALK</h3>
<div id="fig:EGFRm/ALKf" class="fignos">
<figure>
<img src="figureMS5.svg" data-tag="S5" alt="" /><figcaption><span>Figure S5:</span> <strong>Prediction of patient samples harboring EGFR mutations or ALK fusions (EGFRm/ALKf)</strong> A) Phosphorylation signal of DDMC clusters grouped by EGFRm/ALKf mutantants and WT samples. Its statistical significance is indicated on the top part of the plot via a series of Mann Whitney rank test. B) ROC plot of the logistic regression model fit to the DDMC clusters. (D-G) Logo plots of the sequence motifs for clusters 2, 13, 20, and 23. H) Prediction of upstream kinases corresponding to the aforementioned clusters.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="comparing-the-predictive-of-performance-of-using-ddmc-to-different-regression-strategies">Comparing the predictive of performance of using DDMC to different regression strategies</h3>
<div id="fig:RegressionsS" class="fignos">
<figure>
<img src="figureMS6.svg" data-tag="S6" alt="" /><figcaption><span>Figure S6:</span> <strong>Comparing the predictive performance of a logistic regression model using different modeling strategies.</strong> (A-D) Performance of a logistic regression model predicting STK11 mutational status using DDMC clusters (A), unclustered signaling data (B), k-means clusters (C) and GMM clusters (D). Predictive performance of a logistic regression model regressed against EGFRm/ALKf mutational status. Note that a complete portion of the entire data set containing 1311 peptides was used for every modeling strategy other than DDMC. DDMC was fit to 30561 peptides that include at least a minimum of 2 10-plex TMT experiments.</figcaption>
</figure>
</div>
<h2 class="page_break_before" id="references">References</h2>
<!-- Explicitly insert bibliography here -->
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-1702qWji0">
<p>1. T. Hunter, Protein kinases and phosphatases: the yin and yang of protein phosphorylation and signaling. <em>Cell</em>. <strong>80</strong>, 225–36 (1995).</p>
</div>
<div id="ref-D89IOQyu">
<p>2. M. B. Yaffe, Why geneticists stole cancer research even though cancer is primarily a signaling disease. <em>Sci Signal</em>. <strong>12</strong> (2019), doi:<a href="https://doi.org/10.1126/scisignal.aaw3483">10.1126/scisignal.aaw3483</a>.</p>
</div>
<div id="ref-5KmfVMCw">
<p>3. P. Casado, J.-C. Rodriguez-Prados, S. C. Cosulich, S. Guichard, B. Vanhaesebroeck, S. Joel, P. R. Cutillas, Kinase-substrate enrichment analysis provides insights into the heterogeneity of signaling pathway activation in leukemia cells. <em>Sci Signal</em>. <strong>6</strong>, rs6 (2013).</p>
</div>
<div id="ref-t6scDoJj">
<p>4. R. Beekhof, C. van Alphen, A. A. Henneman, J. C. Knol, T. V. Pham, F. Rolfs, M. Labots, E. Henneberry, T. Y. Le Large, R. R. de Haas, S. R. Piersma, V. Vurchio, A. Bertotti, L. Trusolino, H. M. Verheul, C. R. Jimenez, INKA, an integrative data analysis pipeline for phosphoproteomic inference of active kinases. <em>Mol Syst Biol</em>. <strong>15</strong>, e8981 (2019).</p>
</div>
<div id="ref-f3o81IaL">
<p>5. P. V. Hornbeck, J. M. Kornhauser, V. Latham, B. Murray, V. Nandhikonda, A. Nord, E. Skrzypek, T. Wheeler, B. Zhang, F. Gnad, 15 years of PhosphoSitePlus®: integrating post-translationally modified sites, disease variants and isoforms. <em>Nucleic Acids Res</em>. <strong>47</strong>, D433–D441 (2019).</p>
</div>
<div id="ref-1CITWSvkw">
<p>6. R. Linding, L. J. Jensen, G. J. Ostheimer, M. A. T. M. van Vugt, C. Jørgensen, I. M. Miron, F. Diella, K. Colwill, L. Taylor, K. Elder, P. Metalnikov, V. Nguyen, A. Pasculescu, J. Jin, J. G. Park, L. D. Samson, J. R. Woodgett, R. B. Russell, P. Bork, M. B. Yaffe, T. Pawson, Systematic discovery of in vivo phosphorylation networks. <em>Cell</em>. <strong>129</strong>, 1415–26 (2007).</p>
</div>
<div id="ref-Su0yt3JY">
<p>7. J. C. Obenauer, L. C. Cantley, M. B. Yaffe, Scansite 2.0: Proteome-wide prediction of cell signaling interactions using short sequence motifs. <em>Nucleic Acids Res</em>. <strong>31</strong>, 3635–41 (2003).</p>
</div>
<div id="ref-P0XQ2b0s">
<p>8. E. J. Needham, B. L. Parker, T. Burykin, D. E. James, S. J. Humphrey, Illuminating the dark phosphoproteome. <em>Sci Signal</em>. <strong>12</strong> (2019), doi:<a href="https://doi.org/10.1126/scisignal.aau8645">10.1126/scisignal.aau8645</a>.</p>
</div>
<div id="ref-4f8G3SbH">
<p>9. D. L. Tabb, L. Vega-Montoto, P. A. Rudnick, A. M. Variyath, A.-J. L. Ham, D. M. Bunk, L. E. Kilpatrick, D. D. Billheimer, R. K. Blackman, H. L. Cardasis, S. A. Carr, K. R. Clauser, J. D. Jaffe, K. A. Kowalski, T. A. Neubert, F. E. Regnier, B. Schilling, T. J. Tegeler, M. Wang, P. Wang, J. R. Whiteaker, L. J. Zimmerman, S. J. Fisher, B. W. Gibson, C. R. Kinsinger, M. Mesri, H. Rodriguez, S. E. Stein, P. Tempst, A. G. Paulovich, D. C. Liebler, C. Spiegelman, Repeatability and reproducibility in proteomic identifications by liquid chromatography-tandem mass spectrometry. <em>J Proteome Res</em>. <strong>9</strong>, 761–76 (2010).</p>
</div>
<div id="ref-ewa3xhd4">
<p>10. Y.-J. Chen, T. I. Roumeliotis, Y.-H. Chang, C.-T. Chen, C.-L. Han, M.-H. Lin, H.-W. Chen, G.-C. Chang, Y.-L. Chang, C.-T. Wu, M.-W. Lin, M.-S. Hsieh, Y.-T. Wang, Y.-R. Chen, I. Jonassen, F. Z. Ghavidel, Z.-S. Lin, K.-T. Lin, C.-W. Chen, P.-Y. Sheu, C.-T. Hung, K.-C. Huang, H.-C. Yang, P.-Y. Lin, T.-C. Yen, Y.-W. Lin, J.-H. Wang, L. Raghav, C.-Y. Lin, Y.-S. Chen, P.-S. Wu, C.-T. Lai, S.-H. Weng, K.-Y. Su, W.-H. Chang, P.-Y. Tsai, A. I. Robles, H. Rodriguez, Y.-J. Hsiao, W.-H. Chang, T.-Y. Sung, J.-S. Chen, S.-L. Yu, J. S. Choudhary, H.-Y. Chen, P.-C. Yang, Y.-J. Chen, Proteogenomics of Non-smoking Lung Cancer in East Asia Delineates Molecular Signatures of Pathogenesis and Progression. <em>Cell</em>. <strong>182</strong>, 226–244.e17 (2020).</p>
</div>
<div id="ref-Ggt8FNRS">
<p>11. M. A. Gillette, S. Satpathy, S. Cao, S. M. Dhanasekaran, S. V. Vasaikar, K. Krug, F. Petralia, Y. Li, W.-W. Liang, B. Reva, A. Krek, J. Ji, X. Song, W. Liu, R. Hong, L. Yao, L. Blumenberg, S. R. Savage, M. C. Wendl, B. Wen, K. Li, L. C. Tang, M. A. MacMullan, S. C. Avanessian, M. H. Kane, C. J. Newton, M. Cornwell, R. B. Kothadia, W. Ma, S. Yoo, R. Mannan, P. Vats, C. Kumar-Sinha, E. A. Kawaler, T. Omelchenko, A. Colaprico, Y. Geffen, Y. E. Maruvka, F. da Veiga Leprevost, M. Wiznerowicz, Z. H. Gümüş, R. R. Veluswamy, G. Hostetter, D. I. Heiman, M. A. Wyczalkowski, T. Hiltke, M. Mesri, C. R. Kinsinger, E. S. Boja, G. S. Omenn, A. M. Chinnaiyan, H. Rodriguez, Q. K. Li, S. D. Jewell, M. Thiagarajan, G. Getz, B. Zhang, D. Fenyö, K. V. Ruggles, M. P. Cieslik, A. I. Robles, K. R. Clauser, R. Govindan, P. Wang, A. I. Nesvizhskii, L. Ding, D. R. Mani, S. A. Carr,, Proteogenomic Characterization Reveals Therapeutic Vulnerabilities in Lung Adenocarcinoma. <em>Cell</em>. <strong>182</strong>, 200–225.e35 (2020).</p>
</div>
<div id="ref-DVNheP3U">
<p>12. A. Zarrinpar, S.-H. Park, W. A. Lim, Optimization of specificity in a cellular protein interaction network by negative selection. <em>Nature</em>. <strong>426</strong>, 676–80 (2003).</p>
</div>
<div id="ref-j9eQPfet">
<p>13. C. S. H. Tan, A. Pasculescu, W. A. Lim, T. Pawson, G. D. Bader, R. Linding, Positive selection of tyrosine loss in metazoan evolution. <em>Science</em>. <strong>325</strong>, 1686–8 (2009).</p>
</div>
<div id="ref-jW9Cwxfq">
<p>14. T. Obata, M. B. Yaffe, G. G. Leparc, E. T. Piro, H. Maegawa, A. Kashiwagi, R. Kikkawa, L. C. Cantley, Peptide and protein library screening defines optimal substrate motifs for AKT/PKB. <em>J Biol Chem</em>. <strong>275</strong>, 36108–15 (2000).</p>
</div>
<div id="ref-R5sdZXm8">
<p>15. J. Mok, P. M. Kim, H. Y. K. Lam, S. Piccirillo, X. Zhou, G. R. Jeschke, D. L. Sheridan, S. A. Parker, V. Desai, M. Jwa, E. Cameroni, H. Niu, M. Good, A. Remenyi, J.-L. N. Ma, Y.-J. Sheu, H. E. Sassi, R. Sopko, C. S. M. Chan, C. De Virgilio, N. M. Hollingsworth, W. A. Lim, D. F. Stern, B. Stillman, B. J. Andrews, M. B. Gerstein, M. Snyder, B. E. Turk, Deciphering protein kinase specificity through large-scale analysis of yeast phosphorylation site motifs. <em>Sci Signal</em>. <strong>3</strong>, ra12 (2010).</p>
</div>
<div id="ref-h7XI6XcI">
<p>16. B. van de Kooij, P. Creixell, A. van Vlimmeren, B. A. Joughin, C. J. Miller, N. Haider, C. D. Simpson, R. Linding, V. Stambolic, B. E. Turk, M. B. Yaffe, Comprehensive substrate specificity profiling of the human Nek kinome reveals unexpected signaling outputs. <em>Elife</em>. <strong>8</strong> (2019), doi:<a href="https://doi.org/10.7554/elife.44635">10.7554/elife.44635</a>.</p>
</div>
<div id="ref-wUjaVTmV">
<p>17. J. E. Hutti, E. T. Jarrell, J. D. Chang, D. W. Abbott, P. Storz, A. Toker, L. C. Cantley, B. E. Turk, A rapid method for determining protein kinase phosphorylation specificity. <em>Nat Methods</em>. <strong>1</strong>, 27–9 (2004).</p>
</div>
<div id="ref-gYP9Gpwi">
<p>18. M. J. Begley, C.-h. Yun, C. A. Gewinner, J. M. Asara, J. L. Johnson, A. J. Coyle, M. J. Eck, I. Apostolou, L. C. Cantley, EGF-receptor specificity for phosphotyrosine-primed substrates provides signal integration with Src. <em>Nat Struct Mol Biol</em>. <strong>22</strong>, 983–90 (2015).</p>
</div>
<div id="ref-XkcIGLbK">
<p>19. M. L. Miller, L. J. Jensen, F. Diella, C. Jørgensen, M. Tinti, L. Li, M. Hsiung, S. A. Parker, J. Bordeaux, T. Sicheritz-Ponten, M. Olhovsky, A. Pasculescu, J. Alexander, S. Knapp, N. Blom, P. Bork, S. Li, G. Cesareni, T. Pawson, B. E. Turk, M. B. Yaffe, S. Brunak, R. Linding, Linear motif atlas for phosphorylation-dependent signaling. <em>Sci Signal</em>. <strong>1</strong>, ra2 (2008).</p>
</div>
<div id="ref-1CAsv2YaF">
<p>20. M. Hijazi, R. Smith, V. Rajeeve, C. Bessant, P. R. Cutillas, Reconstructing kinase network topologies from phosphoproteomics data reveals cancer-associated rewiring. <em>Nat Biotechnol</em>. <strong>38</strong>, 493–502 (2020).</p>
</div>
<div id="ref-HgmaqMVG">
<p>21. S. M. Carlson, C. R. Chouinard, A. Labadorf, C. J. Lam, K. Schmelzle, E. Fraenkel, F. M. White, Large-scale discovery of ERK2 substrates identifies ERK-mediated transcriptional regulation by ETV3. <em>Sci Signal</em>. <strong>4</strong>, rs11 (2011).</p>
</div>
<div id="ref-ZIstAG1r">
<p>22. L. Moniz, P. Dutt, N. Haider, V. Stambolic, Nek family of kinases in cell cycle, checkpoint control and cancer. <em>Cell Div</em>. <strong>6</strong>, 18 (2011).</p>
</div>
<div id="ref-1563Ps2iZ">
<p>23. G. V. Meirelles, A. M. Perez, E. E. de Souza, F. L. Basei, P. F. Papa, T. D. Melo Hanchuk, V. B. Cardoso, J. Kobarg, “Stop Ne(c)king around”: How interactomics contributes to functionally characterize Nek family kinases. <em>World J Biol Chem</em>. <strong>5</strong>, 141–60 (2014).</p>
</div>
<div id="ref-frubowLH">
<p>24. L. Fabbri, F. Bost, N. M. Mazure, Primary Cilium in Cancer Hallmarks. <em>Int J Mol Sci</em>. <strong>20</strong> (2019), doi:<a href="https://doi.org/10.3390/ijms20061336">10.3390/ijms20061336</a>.</p>
</div>
<div id="ref-fWhtbxpo">
<p>25. O. V. Plotnikova, E. A. Golemis, E. N. Pugacheva, Cell cycle-dependent ciliogenesis and cancer. <em>Cancer Res</em>. <strong>68</strong>, 2058–61 (2008).</p>
</div>
<div id="ref-aG54kP6W">
<p>26. R. M. Brosh, DNA helicases involved in DNA repair and their roles in cancer. <em>Nat Rev Cancer</em>. <strong>13</strong>, 542–58 (2013).</p>
</div>
<div id="ref-sf0tBKVd">
<p>27. J. So, A. Pasculescu, A. Y. Dai, K. Williton, A. James, V. Nguyen, P. Creixell, E. M. Schoof, J. Sinclair, M. Barrios-Rodiles, J. Gu, A. Krizus, R. Williams, M. Olhovsky, J. W. Dennis, J. L. Wrana, R. Linding, C. Jorgensen, T. Pawson, K. Colwill, Integrative analysis of kinase networks in TRAIL-induced apoptosis provides a source of potential targets for combination therapy. <em>Sci Signal</em>. <strong>8</strong>, rs3 (2015).</p>
</div>
<div id="ref-1Bu1guxLX">
<p>28. M. V. Bennetzen, D. H. Larsen, J. Bunkenborg, J. Bartek, J. Lukas, J. S. Andersen, Site-specific phosphorylation dynamics of the nuclear proteome during the DNA damage response. <em>Mol Cell Proteomics</em>. <strong>9</strong>, 1314–23 (2010).</p>
</div>
<div id="ref-17QfmaEkN">
<p>29. A. J. Rabalski, L. Gyenis, D. W. Litchfield, Molecular Pathways: Emergence of Protein Kinase CK2 (CSNK2) as a Potential Target to Inhibit Survival and DNA Damage Response and Repair Pathways in Cancer Cells. <em>Clin Cancer Res</em>. <strong>22</strong>, 2840–7 (2016).</p>
</div>
<div id="ref-1UIt7EAA">
<p>30. A. Siddiqui-Jain, J. Bliesath, D. Macalino, M. Omori, N. Huser, N. Streiner, C. B. Ho, K. Anderes, C. Proffitt, S. E. O’Brien, J. K. C. Lim, D. D. Von Hoff, D. M. Ryckman, W. G. Rice, D. Drygin, CK2 inhibitor CX-4945 suppresses DNA repair response triggered by DNA-targeted anticancer drugs and augments efficacy: mechanistic rationale for drug combination therapy. <em>Mol Cancer Ther</em>. <strong>11</strong>, 994–1005 (2012).</p>
</div>
<div id="ref-11bgLfbny">
<p>31. H. Ji, M. R. Ramsey, D. N. Hayes, C. Fan, K. McNamara, P. Kozlowski, C. Torrice, M. C. Wu, T. Shimamura, S. A. Perera, M.-C. Liang, D. Cai, G. N. Naumov, L. Bao, C. M. Contreras, D. Li, L. Chen, J. Krishnamurthy, J. Koivunen, L. R. Chirieac, R. F. Padera, R. T. Bronson, N. I. Lindeman, D. C. Christiani, X. Lin, G. I. Shapiro, P. A. Jänne, B. E. Johnson, M. Meyerson, D. J. Kwiatkowski, D. H. Castrillon, N. Bardeesy, N. E. Sharpless, K.-K. Wong, LKB1 modulates lung cancer differentiation and metastasis. <em>Nature</em>. <strong>448</strong>, 807–10 (2007).</p>
</div>
<div id="ref-1DOj8GdC6">
<p>32. A. L. Manning, M. S. Longworth, N. J. Dyson, Loss of pRB causes centromere dysfunction and chromosomal instability. <em>Genes Dev</em>. <strong>24</strong>, 1364–76 (2010).</p>
</div>
<div id="ref-1TTuawsr">
<p>33. A. L. Manning, S. A. Yazinski, B. Nicolay, A. Bryll, L. Zou, N. J. Dyson, Suppression of genome instability in pRB-deficient cells by enhancement of chromosome cohesion. <em>Mol Cell</em>. <strong>53</strong>, 993–1004 (2014).</p>
</div>
<div id="ref-M3dxE1vk">
<p>34. M.-H. Nguyen, J. Koinuma, K. Ueda, T. Ito, E. Tsuchiya, Y. Nakamura, Y. Daigo, Phosphorylation and activation of cell division cycle associated 5 by mitogen-activated protein kinase play a crucial role in human lung carcinogenesis. <em>Cancer Res</em>. <strong>70</strong>, 5337–47 (2010).</p>
</div>
<div id="ref-X9fj6E2N">
<p>35. R. H. Hruban, M. I. Canto, M. Goggins, R. Schulick, A. P. Klein, Update on familial pancreatic cancer. <em>Adv Surg</em>. <strong>44</strong>, 293–311 (2010).</p>
</div>
<div id="ref-eQIlwnjX">
<p>36. R. K. Gill, S.-H. Yang, D. Meerzaman, L. E. Mechanic, E. D. Bowman, H.-S. Jeon, S. Roy Chowdhuri, A. Shakoori, T. Dracheva, K.-M. Hong, J. Fukuoka, J.-H. Zhang, C. C. Harris, J. Jen, Frequent homozygous deletion of the LKB1/STK11 gene in non-small cell lung cancer. <em>Oncogene</em>. <strong>30</strong>, 3784–91 (2011).</p>
</div>
<div id="ref-dV6PKXoq">
<p>37. A. Petrosyan, Onco-Golgi: Is Fragmentation a Gate to Cancer Progression? <em>Biochem Mol Biol J</em>. <strong>1</strong> (2015), doi:<a href="https://doi.org/10.21767/2471-8084.100006">10.21767/2471-8084.100006</a>.</p>
</div>
<div id="ref-1GoPZmw6b">
<p>38. X. Hua, L. Yu, W. Pan, X. Huang, Z. Liao, Q. Xian, L. Fang, H. Shen, Increased expression of Golgi phosphoprotein-3 is associated with tumor aggressiveness and poor prognosis of prostate cancer. <em>Diagn Pathol</em>. <strong>7</strong>, 127 (2012).</p>
</div>
<div id="ref-V6txFd6T">
<p>39. Z. Zeng, H. Lin, X. Zhao, G. Liu, X. Wang, R. Xu, K. Chen, J. Li, L. Song, Overexpression of GOLPH3 promotes proliferation and tumorigenicity in breast cancer via suppression of the FOXO1 transcription factor. <em>Clin Cancer Res</em>. <strong>18</strong>, 4059–69 (2012).</p>
</div>
<div id="ref-SMyQ7lQi">
<p>40. B.-S. Hu, H. Hu, C.-Y. Zhu, Y.-L. Gu, J.-P. Li, Overexpression of GOLPH3 is associated with poor clinical outcome in gastric cancer. <em>Tumour Biol</em>. <strong>34</strong>, 515–20 (2012).</p>
</div>
<div id="ref-13s4Fnh0b">
<p>41. T. Sasaki, J. Koivunen, A. Ogino, M. Yanagita, S. Nikiforow, W. Zheng, C. Lathan, J. P. Marcoux, J. Du, K. Okuda, M. Capelletti, T. Shimamura, D. Ercan, M. Stumpfova, Y. Xiao, S. Weremowicz, M. Butaney, S. Heon, K. Wilner, J. G. Christensen, M. J. Eck, K.-K. Wong, N. Lindeman, N. S. Gray, S. J. Rodig, P. A. Jänne, A novel ALK secondary mutation and EGFR signaling cause resistance to ALK kinase inhibitors. <em>Cancer Res</em>. <strong>71</strong>, 6051–60 (2011).</p>
</div>
<div id="ref-OFi5gkLd">
<p>42. M. Miyawaki, H. Yasuda, T. Tani, J. Hamamoto, D. Arai, K. Ishioka, K. Ohgino, S. Nukaga, T. Hirano, I. Kawada, K. Naoki, Y. Hayashi, T. Betsuyaku, K. Soejima, Overcoming EGFR Bypass Signal-Induced Acquired Resistance to ALK Tyrosine Kinase Inhibitors in ALK-Translocated Lung Cancer. <em>Mol Cancer Res</em>. <strong>15</strong>, 106–114 (2016).</p>
</div>
<div id="ref-oDPNDPlI">
<p>43. D. Aran, Z. Hu, A. J. Butte, xCell: digitally portraying the tissue cellular heterogeneity landscape. <em>Genome Biol</em>. <strong>18</strong>, 220 (2017).</p>
</div>
<div id="ref-kQ3GsiVA">
<p>44. A. I. Khan, S. M. Kerfoot, B. Heit, L. Liu, G. Andonegui, B. Ruffell, P. Johnson, P. Kubes, Role of CD44 and hyaluronan in neutrophil recruitment. <em>J Immunol</em>. <strong>173</strong>, 7594–601 (2004).</p>
</div>
<div id="ref-P9l0l2Iw">
<p>45. J. D. Klement, A. V. Paschall, P. S. Redd, M. L. Ibrahim, C. Lu, D. Yang, E. Celis, S. I. Abrams, K. Ozato, K. Liu, An osteopontin/CD44 immune checkpoint controls CD8+ T cell activation and tumor immune evasion. <em>J Clin Invest</em>. <strong>128</strong>, 5549–5560 (2018).</p>
</div>
<div id="ref-qkFzZLTE">
<p>46. C. M. Porter, M. A. Havens, N. A. Clipstone, Identification of amino acid residues and protein kinases involved in the regulation of NFATc subcellular localization. <em>J Biol Chem</em>. <strong>275</strong>, 3543–51 (2000).</p>
</div>
<div id="ref-nHwwoaZ0">
<p>47. W. Yang, S. A. Gibson, Z. Yan, H. Wei, J. Tao, B. Sha, H. Qin, E. N. Benveniste, Protein kinase 2 (CK2) controls CD4. <em>Mucosal Immunol</em>. <strong>13</strong>, 788–798 (2020).</p>
</div>
<div id="ref-IeA9XieB">
<p>48. S. Martínez-Høyer, A. Aranguren-Ibáñez, J. García-García, E. Serrano-Candelas, J. Vilardell, V. Nunes, F. Aguado, B. Oliva, E. Itarte, M. Pérez-Riba, Protein kinase CK2-dependent phosphorylation of the human Regulators of Calcineurin reveals a novel mechanism regulating the calcineurin-NFATc signaling pathway. <em>Biochim Biophys Acta</em>. <strong>1833</strong>, 2311–21 (2013).</p>
</div>
<div id="ref-YLezYGM1">
<p>49. F. Skoulidis, M. E. Goldberg, D. M. Greenawalt, M. D. Hellmann, M. M. Awad, J. F. Gainor, A. B. Schrock, R. J. Hartmaier, S. E. Trabucco, L. Gay, S. M. Ali, J. A. Elvin, G. Singal, J. S. Ross, D. Fabrizio, P. M. Szabo, H. Chang, A. Sasson, S. Srinivasan, S. Kirov, J. Szustakowski, P. Vitazka, R. Edwards, J. A. Bufill, N. Sharma, S.-H. I. Ou, N. Peled, D. R. Spigel, H. Rizvi, E. J. Aguilar, B. W. Carter, J. Erasmus, D. F. Halpenny, A. J. Plodkowski, N. M. Long, M. Nishino, W. L. Denning, A. Galan-Cobo, H. Hamdi, T. Hirz, P. Tong, J. Wang, J. Rodriguez-Canales, P. A. Villalobos, E. R. Parra, N. Kalhor, L. M. Sholl, J. L. Sauter, A. A. Jungbluth, M. Mino-Kenudson, R. Azimi, Y. Y. Elamin, J. Zhang, G. C. Leonardi, F. Jiang, K.-K. Wong, J. J. Lee, V. A. Papadimitrakopoulou, I. I. Wistuba, V. A. Miller, G. M. Frampton, J. D. Wolchok, A. T. Shaw, P. A. Jänne, P. J. Stephens, C. M. Rudin, W. J. Geese, L. A. Albacker, J. V. Heymach, <em>Cancer Discov</em>. <strong>8</strong>, 822–835 (2018).</p>
</div>
<div id="ref-QJFQ9RQQ">
<p>50. K. Kourou, T. P. Exarchos, K. P. Exarchos, M. V. Karamouzis, D. I. Fotiadis, Machine learning applications in cancer prognosis and prediction. <em>Comput Struct Biotechnol J</em>. <strong>13</strong>, 8–17 (2014).</p>
</div>
<div id="ref-bRPGEQL4">
<p>51. N. H. Shah, M. Löbel, A. Weiss, J. Kuriyan, Fine-tuning of substrate preferences of the Src-family kinase Lck revealed through a high-throughput specificity screen. <em>Elife</em>. <strong>7</strong> (2018), doi:<a href="https://doi.org/10.7554/elife.35190">10.7554/elife.35190</a>.</p>
</div>
<div id="ref-dbN6HcER">
<p>52. B. Deb, P. Sengupta, J. Sambath, P. Kumar, Bioinformatics Analysis of Global Proteomic and Phosphoproteomic Data Sets Revealed Activation of NEK2 and AURKA in Cancers. <em>Biomolecules</em>. <strong>10</strong> (2020), doi:<a href="https://doi.org/10.3390/biom10020237">10.3390/biom10020237</a>.</p>
</div>
<div id="ref-12p8KTQaG">
<p>53. R. Beekhof, C. van Alphen, A. A. Henneman, J. C. Knol, T. V. Pham, F. Rolfs, M. Labots, E. Henneberry, T. Y. Le Large, R. R. de Haas, S. R. Piersma, V. Vurchio, A. Bertotti, L. Trusolino, H. M. Verheul, C. R. Jimenez, INKA, an integrative data analysis pipeline for phosphoproteomic inference of active kinases. <em>Mol Syst Biol</em>. <strong>15</strong>, e8250 (2019).</p>
</div>
<div id="ref-1AT5pt9hP">
<p>54. K. P. Exarchos, Y. Goletsis, D. I. Fotiadis, Multiparametric decision support system for the prediction of oral cancer reoccurrence. <em>IEEE Trans Inf Technol Biomed</em>. <strong>16</strong>, 1127–34 (2011).</p>
</div>
<div id="ref-tatP35Vj">
<p>55. D. Schwartz, S. P. Gygi, An iterative statistical approach to the identification of protein phosphorylation motifs from large-scale data sets. <em>Nat Biotechnol</em>. <strong>23</strong>, 1391–8 (2005).</p>
</div>
<div id="ref-17tuo8dIX">
<p>56. A. Tareen, J. B. Kinney, Logomaker: Beautiful sequence logos in python. <em>Cold Spring Harbor Laboratory</em> (2019), doi:<a href="https://doi.org/10.1101/635029">10.1101/635029</a>.</p>
</div>
<div id="ref-IFevKgND">
<p>57. M. Ashburner, C. A. Ball, J. A. Blake, D. Botstein, H. Butler, J. M. Cherry, A. P. Davis, K. Dolinski, S. S. Dwight, J. T. Eppig, M. A. Harris, D. P. Hill, L. Issel-Tarver, A. Kasarskis, S. Lewis, J. C. Matese, J. E. Richardson, M. Ringwald, G. M. Rubin, G. Sherlock, Gene ontology: tool for the unification of biology. The Gene Ontology Consortium. <em>Nat Genet</em>. <strong>25</strong>, 25–9 (2000).</p>
</div>
<div id="ref-1FmAqWcpa">
<p>58. The Gene Ontology resource: enriching a GOld mine. <em>Nucleic Acids Res</em>. <strong>49</strong>, D325–D334 (2021).</p>
</div>
</div>
<!-- default theme -->

<style>
    /* import google fonts */
    @import url("https://fonts.googleapis.com/css?family=Open+Sans:400,600,700");
    @import url("https://fonts.googleapis.com/css?family=Source+Code+Pro");

    /* -------------------------------------------------- */
    /* global */
    /* -------------------------------------------------- */

    /* all elements */
    * {
        /* force sans-serif font unless specified otherwise */
        font-family: "Open Sans", "Helvetica", sans-serif;

        /* prevent text inflation on some mobile browsers */
        -webkit-text-size-adjust: none !important;
        -moz-text-size-adjust: none !important;
        -o-text-size-adjust: none !important;
        text-size-adjust: none !important;
    }

    @media only screen {
        /* "page" element */
        body {
            position: relative;
            box-sizing: border-box;
            font-size: 12pt;
            line-height: 1.5;
            max-width: 8.5in;
            margin: 20px auto;
            padding: 40px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* "page" element */
        body {
            padding: 20px;
            margin: 0;
            border-radius: 0;
            border: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05) inset;
            background: none;
        }
    }

    /* -------------------------------------------------- */
    /* headings */
    /* -------------------------------------------------- */

    /* all headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        margin: 20px 0;
        padding: 0;
        font-weight: bold;
    }

    /* biggest heading */
    h1 {
        margin: 40px 0;
        text-align: center;
    }

    /* second biggest heading */
    h2 {
        margin-top: 30px;
        padding-bottom: 5px;
        border-bottom: solid 1px #bdbdbd;
    }

    /* -------------------------------------------------- */
    /* manuscript header */
    /* -------------------------------------------------- */

    /* manuscript title */
    header > h1 {
        margin: 0;
    }

    /* manuscript title caption text (ie "automatically generated on") */
    header + p {
        text-align: center;
        margin-top: 10px;
    }

    /* -------------------------------------------------- */
    /* text elements */
    /* -------------------------------------------------- */

    /* links */
    a {
        color: #2196f3;
        overflow-wrap: break-word;
    }

    /* normal links (not empty, not button link, not syntax highlighting link) */
    a:not(:empty):not(.button):not(.sourceLine) {
        padding-left: 1px;
        padding-right: 1px;
    }

    /* superscripts and subscripts */
    sub,
    sup {
        /* prevent from affecting line height */
        line-height: 0;
    }

    /* unordered and ordered lists*/
    ul,
    ol {
        padding-left: 20px;
    }

    /* class for styling text semibold */
    .semibold {
        font-weight: 600;
    }

    /* class for styling elements horizontally left aligned */
    .left {
        display: block;
        text-align: left;
        margin-left: auto;
        margin-right: 0;
        justify-content: left;
    }

    /* class for styling elements horizontally centered */
    .center {
        display: block;
        text-align: center;
        margin-left: auto;
        margin-right: auto;
        justify-content: center;
    }

    /* class for styling elements horizontally right aligned */
    .right {
        display: block;
        text-align: right;
        margin-left: 0;
        margin-right: auto;
        justify-content: right;
    }

    /* -------------------------------------------------- */
    /* section elements */
    /* -------------------------------------------------- */

    /* horizontal divider line */
    hr {
        border: none;
        height: 1px;
        background: #bdbdbd;
    }

    /* paragraphs, horizontal dividers, figures, tables, code */
    p,
    hr,
    figure,
    table,
    pre {
        /* treat all as "paragraphs", with consistent vertical margins */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* figures */
    /* -------------------------------------------------- */

    /* figure */
    figure {
        max-width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure caption */
    figcaption {
        padding: 0;
        padding-top: 10px;
    }

    /* figure image element */
    figure img {
        max-width: 100%;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure auto-number */
    img + figcaption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* tables */
    /* -------------------------------------------------- */

    /* table */
    table {
        border-collapse: collapse;
        border-spacing: 0;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* table cells */
    th,
    td {
        border: solid 1px #bdbdbd;
        padding: 10px;
        /* squash table if too wide for page by forcing line breaks */
        overflow-wrap: break-word;
        word-break: break-word;
    }

    /* header row and even rows */
    th,
    tr:nth-child(2n) {
        background-color: #fafafa;
    }

    /* odd rows */
    tr:nth-child(2n + 1) {
        background-color: #ffffff;
    }

    /* table caption */
    caption {
        text-align: left;
        padding: 0;
        padding-bottom: 10px;
    }

    /* table auto-number */
    table > caption > span:first-of-type,
    div.table_wrapper > table > caption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* code */
    /* -------------------------------------------------- */

    /* multi-line code block */
    pre {
        padding: 10px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
        break-inside: avoid;
        text-align: left;
    }

    /* inline code, ie code within normal text */
    :not(pre) > code {
        padding: 0 4px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
    }

    /* code text */
    /* apply all children, to reach syntax highlighting sub-elements */
    code,
    code * {
        /* force monospace font */
        font-family: "Source Code Pro", "Courier New", monospace;
    }

    /* -------------------------------------------------- */
    /* quotes */
    /* -------------------------------------------------- */

    /* quoted text */
    blockquote {
        margin: 0;
        padding: 0;
        border-left: 4px solid #bdbdbd;
        padding-left: 16px;
        break-inside: avoid;
    }

    /* -------------------------------------------------- */
    /* banners */
    /* -------------------------------------------------- */

    /* info banners */
    .banner {
        box-sizing: border-box;
        display: block;
        position: relative;
        width: 100%;
        margin-top: 20px;
        margin-bottom: 20px;
        padding: 20px;
        text-align: center;
    }

    /* paragraph in banner */
    .banner > p {
        margin: 0;
    }

    /* -------------------------------------------------- */
    /* highlight colors */
    /* -------------------------------------------------- */

    .white {
        background: #ffffff;
    }
    .lightgrey {
        background: #eeeeee;
    }
    .grey {
        background: #757575;
    }
    .darkgrey {
        background: #424242;
    }
    .black {
        background: #000000;
    }
    .lightred {
        background: #ffcdd2;
    }
    .lightyellow {
        background: #ffecb3;
    }
    .lightgreen {
        background: #dcedc8;
    }
    .lightblue {
        background: #e3f2fd;
    }
    .lightpurple {
        background: #f3e5f5;
    }
    .red {
        background: #f44336;
    }
    .orange {
        background: #ff9800;
    }
    .yellow {
        background: #ffeb3b;
    }
    .green {
        background: #4caf50;
    }
    .blue {
        background: #2196f3;
    }
    .purple {
        background: #9c27b0;
    }
    .white,
    .lightgrey,
    .lightred,
    .lightyellow,
    .lightgreen,
    .lightblue,
    .lightpurple,
    .orange,
    .yellow,
    .white a,
    .lightgrey a,
    .lightred a,
    .lightyellow a,
    .lightgreen a,
    .lightblue a,
    .lightpurple a,
    .orange a,
    .yellow a {
        color: #000000;
    }
    .grey,
    .darkgrey,
    .black,
    .red,
    .green,
    .blue,
    .purple,
    .grey a,
    .darkgrey a,
    .black a,
    .red a,
    .green a,
    .blue a,
    .purple a {
        color: #ffffff;
    }

    /* -------------------------------------------------- */
    /* buttons */
    /* -------------------------------------------------- */

    /* class for styling links like buttons */
    .button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        margin: 5px;
        padding: 10px 20px;
        font-size: 0.75em;
        font-weight: 600;
        text-transform: uppercase;
        text-decoration: none;
        letter-spacing: 1px;
        background: none;
        color: #2196f3;
        border: solid 1px #bdbdbd;
        border-radius: 5px;
    }

    /* buttons when hovered */
    .button:hover:not([disabled]),
    .icon_button:hover:not([disabled]) {
        cursor: pointer;
        background: #f5f5f5;
    }

    /* buttons when disabled */
    .button[disabled],
    .icon_button[disabled] {
        opacity: 0.35;
        pointer-events: none;
    }

    /* class for styling buttons containg only single icon */
    .icon_button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        text-decoration: none;
        margin: 0;
        padding: 0;
        background: none;
        border-radius: 5px;
        border: none;
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
    }

    /* icon button inner svg image */
    .icon_button > svg {
        height: 16px;
    }

    /* -------------------------------------------------- */
    /* icons */
    /* -------------------------------------------------- */

    /* class for styling icons inline with text */
    .inline_icon {
        height: 1em;
        position: relative;
        top: 0.125em;
    }

    /* -------------------------------------------------- */
    /* print control */
    /* -------------------------------------------------- */

    @media print {
        @page {
            /* suggested printing margin */
            margin: 0.5in;
        }

        /* document and "page" elements */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        /* "page" element */
        body {
            font-size: 11pt !important;
            line-height: 1.35;
        }

        /* all headings */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin: 15px 0;
        }

        /* heading 1 */
        h1 {
            font-size: 1.75em;
        }

        /* heading 2 */
        h2 {
            font-size: 1.25em;
            margin-top: 0;
        }

        /* heading 3 */
        h3 {
            font-size: 1.10em;
        }

        /* figures and tables */
        figure, table {
            font-size: 0.85em;
        }

        /* table cells */
        th,
        td {
            padding: 5px;
        }

        /* shrink font awesome icons */
        i.fas,
        i.fab,
        i.far,
        i.fal {
            transform: scale(0.85);
        }

        /* decrease banner margins */
        .banner {
            margin-top: 15px;
            margin-bottom: 15px;
            padding: 15px;
        }

        /* class for centering an element vertically on its own page */
        .page_center {
            margin: auto;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            vertical-align: middle;
            break-before: page;
            break-after: page;
        }

        /* always insert a page break before the element */
        .page_break_before {
            break-before: page;
        }

        /* always insert a page break after the element */
        .page_break_after {
            break-after: page;
        }

        /* avoid page break before the element */
        .page_break_before_avoid {
            break-before: avoid;
        }

        /* avoid page break after the element */
        .page_break_after_avoid {
            break-after: avoid;
        }

        /* avoid page break inside the element */
        .page_break_inside_avoid {
            break-inside: avoid;
        }
    }

    /* -------------------------------------------------- */
    /* override pandoc css quirks */
    /* -------------------------------------------------- */

    .sourceCode {
        /* prevent unsightly overflow in wide code blocks */
        overflow: auto !important;
    }

    div.sourceCode {
        /* prevent background fill on top-most code block  container */
        background: none !important;
    }

    .sourceCode * {
        /* force consistent line spacing */
        line-height: 1.5 !important;
    }

    div.sourceCode {
        /* style code block margins same as <pre> element */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* tablenos */
    /* -------------------------------------------------- */

    /* tablenos wrapper */
    .tablenos {
        /* show scrollbar on tables if necessary to prevent overflow */
        width: 100%;
        margin: 20px 0;
    }

    .tablenos > table {
        /* move margins from table to table_wrapper to allow margin collapsing */
        margin: 0;
    }

    @media only screen {
        /* tablenos wrapper */
        .tablenos {
            /* show scrollbar on tables if necessary to prevent overflow */
            overflow-x: auto !important;
        }

        .tablenos th,
        .tablenos td {
            overflow-wrap: unset !important;
            word-break: unset !important;
        }

        /* table in wrapper */
        .tablenos table,
        .tablenos table * {
            /* don't break table words */
            overflow-wrap: normal !important;
        }
    }

    /* -------------------------------------------------- */
    /* mathjax */
    /* -------------------------------------------------- */

    /* mathjax containers */
    .math.display > span:not(.MathJax_Preview) {
        /* turn inline element (no dimensions) into block (allows fixed width and thus scrolling) */
        display: flex !important;
        overflow-x: auto !important;
        overflow-y: hidden !important;
        justify-content: center;
        align-items: center;
        margin: 0 !important;
    }

    /* right click menu */
    .MathJax_Menu {
        border-radius: 5px !important;
        border: solid 1px #bdbdbd !important;
        box-shadow: none !important;
    }

    /* equation auto-number */
    span[id^="eq:"] > span.math.display + span {
        font-weight: 600;
    }

    /* equation */
    span[id^="eq:"] > span.math.display > span {
        /* nudge to make room for equation auto-number and anchor */
        margin-right: 60px !important;
    }

    /* -------------------------------------------------- */
    /* anchors plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anchor button */
        .anchor {
            opacity: 0;
            margin-left: 5px;
        }

        /* anchor buttons within <h2>'s */
        h2 .anchor {
            margin-left: 10px;
        }

        /* anchor buttons when hovered/focused and anything containing an anchor button when hovered */
        *:hover > .anchor,
        .anchor:hover,
        .anchor:focus {
            opacity: 1;
        }

        /* anchor button when hovered */
        .anchor:hover {
            cursor: pointer;
        }
    }

    /* always show anchor button on devices with no mouse/hover ability */
    @media (hover: none) {
        .anchor {
            opacity: 1;
        }
    }

    /* always hide anchor button on print */
    @media only print {
        .anchor {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* accordion plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* accordion arrow button */
        .accordion_arrow {
            margin-right: 10px;
        }

        /* arrow icon when <h2> data-collapsed attribute true */
        h2[data-collapsed="true"] > .accordion_arrow > svg {
            transform: rotate(-90deg);
        }

        /* all elements (except <h2>'s) when data-collapsed attribute true */
        *:not(h2)[data-collapsed="true"] {
            display: none;
        }

        /* accordion arrow button when hovered and <h2>'s when hovered */
        .accordion_arrow:hover,
        h2[data-collapsed="true"]:hover,
        h2[data-collapsed="false"]:hover {
            cursor: pointer;
        }
    }

    /* always hide accordion arrow button on print */
    @media only print {
        .accordion_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* tooltips plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* tooltip container */
        #tooltip {
            position: absolute;
            width: 50%;
            min-width: 240px;
            max-width: 75%;
            z-index: 1;
        }

        /* tooltip content */
        #tooltip_content {
            margin-bottom: 5px;
            padding: 20px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
            overflow-wrap: break-word;
        }

        /* tooltip copy of paragraphs and figures */
        #tooltip_content > p,
        #tooltip_content > figure {
            margin: 0;
            max-height: 320px;
            overflow-y: auto;
        }

        /* tooltip copy of <img> */
        #tooltip_content > figure > img {
            max-height: 260px;
        }

        /* navigation bar */
        #tooltip_nav_bar {
            margin-top: 10px;
            text-align: center;
        }

        /* navigation bar previous/next buton */
        #tooltip_nav_bar > .icon_button {
            position: relative;
            top: 3px;
        }

        /* navigation bar previous button */
        #tooltip_nav_bar > .icon_button:first-of-type {
            margin-right: 5px;
        }

        /* navigation bar next button */
        #tooltip_nav_bar > .icon_button:last-of-type {
            margin-left: 5px;
        }
    }

    /* always hide tooltip on print */
    @media only print {
        #tooltip {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* jump to first plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* jump button */
        .jump_arrow {
            position: relative;
            top: 0.125em;
            margin-right: 5px;
        }
    }

    /* always hide jump button on print */
    @media only print {
        .jump_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* link highlight plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anything with data-highlighted attribute true */
        [data-highlighted="true"] {
            background: #ffeb3b;
        }

        /* anything with data-selected attribute true */
        [data-selected="true"] {
            background: #ff8a65 !important;
        }

        /* animation definition for glow */
        @keyframes highlight_glow {
            0% {
                background: none;
            }
            10% {
                background: #bbdefb;
            }
            100% {
                background: none;
            }
        }

        /* anything with data-glow attribute true */
        [data-glow="true"] {
            animation: highlight_glow 2s;
        }
    }

    /* -------------------------------------------------- */
    /* table of contents plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* toc panel */
        #toc_panel {
            box-sizing: border-box;
            position: fixed;
            top: 0;
            left: 0;
            background: #ffffff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            z-index: 2;
        }

        /* toc panel when closed */
        #toc_panel[data-open="false"] {
            min-width: 60px;
            width: 60px;
            height: 60px;
            border-right: solid 1px #bdbdbd;
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc panel when open */
        #toc_panel[data-open="true"] {
            min-width: 260px;
            max-width: 480px;
            /* keep panel edge consistent distance away from "page" edge */
            width: calc(((100vw - 8.5in) / 2) - 30px - 40px);
            bottom: 0;
            border-right: solid 1px #bdbdbd;
        }

        /* toc panel header */
        #toc_header {
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            align-items: center;
            height: 60px;
            margin: 0;
            padding: 20px;
        }

        /* toc panel header when hovered */
        #toc_header:hover {
            cursor: pointer;
        }

        /* toc panel header when panel open */
        #toc_panel[data-open="true"] > #toc_header {
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc open/close header button */
        #toc_button {
            margin-right: 20px;
        }

        /* hide toc list and header text when closed */
        #toc_panel[data-open="false"] > #toc_header > *:not(#toc_button),
        #toc_panel[data-open="false"] > #toc_list {
            display: none;
        }

        /* toc list of entries */
        #toc_list {
            box-sizing: border-box;
            width: 100%;
            padding: 20px;
            position: absolute;
            top: calc(60px + 1px);
            bottom: 0;
            overflow: auto;
        }

        /* toc entry, link to section in document */
        .toc_link {
            display: block;
            padding: 5px;
            position: relative;
            font-weight: 600;
            text-decoration: none;
        }

        /* toc entry when hovered or when "viewed" */
        .toc_link:hover,
        .toc_link[data-viewing="true"] {
            background: #f5f5f5;
        }

        /* toc entry, level 1 indentation */
        .toc_link[data-level="1"] {
            margin-left: 0;
        }

        /* toc entry, level 2 indentation */
        .toc_link[data-level="2"] {
            margin-left: 20px;
        }

        /* toc entry, level 3 indentation */
        .toc_link[data-level="3"] {
            margin-left: 40px;
        }

        /* toc entry, level 4 indentation */
        .toc_link[data-level="4"] {
            margin-left: 60px;
        }

        /* toc entry bullets */
        #toc_panel[data-bullets="true"] .toc_link[data-level]:before {
            position: absolute;
            left: -15px;
            top: -1px;
            font-size: 1.5em;
        }

        /* toc entry, level 2 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="2"]:before {
            content: "\2022";
        }

        /* toc entry, level 3 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="3"]:before {
            content: "\25AB";
        }

        /* toc entry, level 4 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="4"]:before {
            content: "-";
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* push <body> ("page") element down to make room for toc icon */
        .toc_body_nudge {
            padding-top: 60px;
        }

        /* toc icon when panel closed and not hovered */
        #toc_panel[data-open="false"]:not(:hover) {
            background: rgba(255, 255, 255, 0.75);
        }
    }

    /* always hide toc panel on print */
    @media only print {
        #toc_panel {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* lightbox plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* regular <img> in document when hovered */
        .lightbox_document_img:hover {
            cursor: pointer;
        }

        .body_no_scroll {
            overflow: hidden !important;
        }

        /* screen overlay */
        #lightbox_overlay {
            display: flex;
            flex-direction: column;
            position: fixed;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 3;
        }

        /* middle area containing lightbox image */
        #lightbox_image_container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 20px;
        }

        /* bottom area containing caption */
        #lightbox_bottom_container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            min-height: 100px;
            max-height: 100px;
            background: rgba(0, 0, 0, 0.5);
        }

        /* image number info text box */
        #lightbox_number_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            left: 2px;
            top: 0;
            z-index: 4;
        }

        /* zoom info text box */
        #lightbox_zoom_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            right: 2px;
            top: 0;
            z-index: 4;
        }

        /* copy of image caption */
        #lightbox_caption {
            box-sizing: border-box;
            display: inline-block;
            width: 100%;
            max-height: 100%;
            padding: 10px 0;
            text-align: center;
            overflow-y: auto;
            color: #ffffff;
        }

        /* navigation previous/next button */
        .lightbox_button {
            width: 100px;
            height: 100%;
            min-width: 100px;
            min-height: 100%;
            color: #ffffff;
        }

        /* navigation previous/next button when hovered */
        .lightbox_button:hover {
            background: none !important;
        }

        /* navigation button icon */
        .lightbox_button > svg {
            height: 25px;
        }

        /* figure auto-number */
        #lightbox_caption > span:first-of-type {
            font-weight: bold;
            margin-right: 5px;
        }

        /* lightbox image when hovered */
        #lightbox_img:hover {
            cursor: grab;
        }

        /* lightbox image when grabbed */
        #lightbox_img:active {
            cursor: grabbing;
        }
    }

    /* when on screen < 480px wide */
    @media only screen and (max-width: 480px) {
        /* make navigation buttons skinnier on small screens to make more room for caption text */
        .lightbox_button {
            width: 50px;
            min-width: 50px;
        }
    }

    /* always hide lightbox on print */
    @media only print {
        #lightbox_overlay {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* hypothesis (annotations) plugin */
    /* -------------------------------------------------- */

    /* side panel */
    .annotator-frame {
        width: 280px !important;
        z-index: 0 !important;
    }

    /* match highlight color to rest of theme */
    .annotator-highlights-always-on .annotator-hl {
        background-color: #ffeb3b !important;
    }

    /* match focused color to rest of theme */
    .annotator-hl.annotator-hl-focused {
        background-color: #ff8a65 !important;
    }

    /* match bucket bar color to rest of theme */
    .annotator-bucket-bar {
        background: #f5f5f5 !important;
    }

    /* always hide toolbar and tooltip on print */
    @media only print {
        .annotator-frame {
            display: none !important;
        }

        hypothesis-adder {
            display: none !important;
        }
    }
</style>
<!-- anchors plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds an anchor next to each of a certain type
        // of element that provides a human-readable url to that specific
        // item/position in the document (eg "manuscript.html#abstract"). It
        // also makes it such that scrolling out of view of a target removes
        // its identifier from the url.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'anchors';

        // default plugin options
        const options = {
            // which types of elements to add anchors next to, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3, [id^="fig:"], [id^="tbl:"], [id^="eq:"]',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // add anchor to each element of specified types
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements)
                addAnchor(element);

            // attach scroll listener to window
            window.addEventListener('scroll', onScroll);
        }

        // when window is scrolled
        function onScroll() {
            // if url has hash and user has scrolled out of view of hash
            // target, remove hash from url
            const tolerance = 100;
            const target = getHashTarget();
            if (target) {
                if (
                    target.getBoundingClientRect().top >
                        window.innerHeight + tolerance ||
                    target.getBoundingClientRect().bottom < 0 - tolerance
                )
                    history.pushState(null, null, ' ');
            }
        }

        // add anchor to element
        function addAnchor(element) {
            let addTo; // element to add anchor button to

            // if figure or table, modify withId and addTo to get expected
            // elements
            if (element.id.indexOf('fig:') === 0) {
                addTo = element.querySelector('figcaption');
            } else if (element.id.indexOf('tbl:') === 0) {
                addTo = element.querySelector('caption');
            } else if (element.id.indexOf('eq:') === 0) {
                addTo = element.querySelector('.eqnos-number');
            }

            addTo = addTo || element;
            const id = element.id || null;

            // do not add anchor if element doesn't have assigned id.
            // id is generated by pandoc and is assumed to be unique and
            // human-readable
            if (!id)
                return;

            // create anchor button
            const anchor = document.createElement('a');
            anchor.innerHTML = document.querySelector('.icon_link').innerHTML;
            anchor.title = 'Link to this part of the document';
            anchor.classList.add('icon_button', 'anchor');
            anchor.dataset.ignore = 'true';
            anchor.href = '#' + id;
            addTo.appendChild(anchor);
        }

        // get element that is target of link or url hash
        function getHashTarget() {
            const hash = window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');
            if (id.indexOf('tbl:') === 0)
                target = target.querySelector('table');

            return target;
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- link icon -->

<template class="icon_link">
    <!-- modified from: https://fontawesome.com/icons/link -->
    <svg width="16" height="16" viewBox="0 0 512 512">
        <path
            fill="currentColor"
            d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"
        ></path>
    </svg>
</template>
<!-- accordion plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows sections of content under <h2> headings
        // to be collapsible.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'accordion';

        // default plugin options
        const options = {
            // whether to always start expanded ('false'), always start
            // collapsed ('true'), or start collapsed when screen small ('auto')
            startCollapsed: 'auto',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <h2> heading
            const headings = document.querySelectorAll('h2');
            for (const heading of headings) {
                addArrow(heading);

                // start expanded/collapsed based on option
                if (
                    options.startCollapsed === 'true' ||
                    (options.startCollapsed === 'auto' && isSmallScreen())
                )
                    collapseHeading(heading);
                else
                    expandHeading(heading);
            }

            // attach hash change listener to window
            window.addEventListener('hashchange', onHashChange);
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                goToElement(target);
        }

        // add arrow to heading
        function addArrow(heading) {
            // add arrow button
            const arrow = document.createElement('button');
            arrow.innerHTML = document.querySelector(
                '.icon_angle_down'
            ).innerHTML;
            arrow.classList.add('icon_button', 'accordion_arrow');
            heading.insertBefore(arrow, heading.firstChild);

            // attach click listener to heading and button
            heading.addEventListener('click', onHeadingClick);
            arrow.addEventListener('click', onArrowClick);
        }

        // determine if on mobile-like device with small screen
        function isSmallScreen() {
            return Math.min(window.innerWidth, window.innerHeight) < 480;
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get element that is target of hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');
            if (id.indexOf('tbl:') === 0)
                target = target.querySelector('table');

            return target;
        }

        // when <h2> heading is clicked
        function onHeadingClick(event) {
            // only collapse if <h2> itself is target of click (eg, user did
            // not click on anchor within <h2>)
            if (event.target === this)
                toggleCollapse(this);
        }

        // when arrow button is clicked
        function onArrowClick() {
            toggleCollapse(this.parentNode);
        }

        // collapse section if expanded, expand if collapsed
        function toggleCollapse(heading) {
            if (heading.dataset.collapsed === 'false')
                collapseHeading(heading);
            else
                expandHeading(heading);
        }

        // elements to exclude from collapse, such as table of contents panel,
        // hypothesis panel, etc
        const exclude = '#toc_panel, div.annotator-frame, #lightbox_overlay';

        // collapse section
        function collapseHeading(heading) {
            heading.setAttribute('data-collapsed', 'true');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'true');
        }

        // expand section
        function expandHeading(heading) {
            heading.setAttribute('data-collapsed', 'false');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'false');
        }

        // get list of elements between this <h2> and next <h2> or <h1>
        // ("children" of the <h2> section)
        function getChildren(heading) {
            return nextUntil(heading, 'h2, h1', exclude);
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get list of elements after a start element up to element matching
        // query
        function nextUntil(element, query, exclude) {
            const elements = [];
            while (element = element.nextElementSibling, element) {
                if (element.matches(query))
                    break;
                if (!element.matches(exclude))
                    elements.push(element);
            }
            return elements;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle down icon -->

<template class="icon_angle_down">
    <!-- modified from: https://fontawesome.com/icons/angle-down -->
    <svg width="16" height="16" viewBox="0 0 448 512">
        <path
            fill="currentColor"
            d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"
        ></path>
    </svg>
</template>
<!-- tooltips plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when the user hovers or
        // focuses a link to a citation or figure, a tooltip appears with a
        // preview of the reference content, along with arrows to navigate
        // between instances of the same reference in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tooltips';

        // default plugin options
        const options = {
            // whether user must click off to close tooltip instead of just
            // un-hovering
            clickClose: 'false',
            // delay (in ms) between opening and closing tooltip
            delay: '100',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach hover and focus listeners to link
                link.addEventListener('mouseover', onLinkHover);
                link.addEventListener('mouseleave', onLinkUnhover);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('touchend', onLinkTouch);
            }

            // attach mouse, key, and resize listeners to window
            window.addEventListener('mousedown', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onResize);
        }

        // when link is hovered
        function onLinkHover() {
            // function to open tooltip
            const delayOpenTooltip = function() {
                openTooltip(this);
            }.bind(this);

            // run open function after delay
            this.openTooltipTimer = window.setTimeout(
                delayOpenTooltip,
                options.delay
            );
        }

        // when mouse leaves link
        function onLinkUnhover() {
            // cancel opening tooltip
            window.clearTimeout(this.openTooltipTimer);

            // don't close on unhover if option specifies
            if (options.clickClose === 'true')
                return;

            // function to close tooltip
            const delayCloseTooltip = function() {
                // if tooltip open and if mouse isn't over tooltip, close
                const tooltip = document.getElementById('tooltip');
                if (tooltip && !tooltip.matches(':hover'))
                    closeTooltip();
            };

            // run close function after delay
            this.closeTooltipTimer = window.setTimeout(
                delayCloseTooltip,
                options.delay
            );
        }

        // when link is focused (tabbed to)
        function onLinkFocus(event) {
            openTooltip(this);
        }

        // when link is touched on touch screen
        function onLinkTouch(event) {
            // attempt to force hover state on first tap always, and trigger
            // regular link click (and navigation) on second tap
            if (event.target === document.activeElement)
                event.target.click();
            else {
                document.activeElement.blur();
                event.target.focus();
            }
            if (event.cancelable)
                event.preventDefault();
            event.stopPropagation();
            return false;
        }

        // when mouse is clicked anywhere in window
        function onClick(event) {
            closeTooltip();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'tooltip_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'tooltip_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeTooltip();
                    break;
            }
        }

        // when window is resized or zoomed
        function onResize() {
            closeTooltip();
        }

        // get all links of types we wish to handle
        function getLinks() {
            const queries = [];
            // exclude buttons, anchor links, toc links, etc
            const exclude =
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            queries.push('a[href^="#ref-"]' + exclude); // citation links
            queries.push('a[href^="#fig:"]' + exclude); // figure links
            const query = queries.join(', ');
            return document.querySelectorAll(query);
        }

        // get links with same target, get index of link in set, get total
        // same links
        function getSameLinks(link) {
            const sameLinks = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    sameLinks.push(otherLink);
            }

            return {
                elements: sameLinks,
                index: sameLinks.indexOf(link),
                total: sameLinks.length
            };
        }

        // open tooltip
        function openTooltip(link) {
            // delete tooltip if it exists, start fresh
            closeTooltip();

            // make tooltip element
            const tooltip = makeTooltip(link);

            // if source couldn't be found and tooltip not made, exit
            if (!tooltip)
                return;

            // make navbar elements
            const navBar = makeNavBar(link);
            if (navBar)
                tooltip.firstElementChild.appendChild(navBar);

            // attach tooltip to page
            document.body.appendChild(tooltip);

            // position tooltip
            const position = function() {
                positionTooltip(link);
            };
            position();

            // if tooltip contains images, position again after they've loaded
            const imgs = tooltip.querySelectorAll('img');
            for (const img of imgs)
                img.addEventListener('load', position);
        }

        // close (delete) tooltip
        function closeTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip)
                tooltip.remove();
        }

        // make tooltip
        function makeTooltip(link) {
            // get target element that link points to
            const source = getSource(link);

            // if source can't be found, exit
            if (!source)
                return;

            // create new tooltip
            const tooltip = document.createElement('div');
            tooltip.id = 'tooltip';
            const tooltipContent = document.createElement('div');
            tooltipContent.id = 'tooltip_content';
            tooltip.appendChild(tooltipContent);

            // make copy of source node and put in tooltip
            const sourceCopy = makeCopy(source);
            tooltipContent.appendChild(sourceCopy);

            // attach mouse event listeners
            tooltip.addEventListener('click', onTooltipClick);
            tooltip.addEventListener('mousedown', onTooltipClick);
            tooltip.addEventListener('touchstart', onTooltipClick);
            tooltip.addEventListener('mouseleave', onTooltipUnhover);

            // (for interaction with lightbox plugin)
            // transfer click on tooltip copied img to original img
            const sourceImg = source.querySelector('img');
            const sourceCopyImg = sourceCopy.querySelector('img');
            if (sourceImg && sourceCopyImg) {
                const clickImg = function() {
                    sourceImg.click();
                    closeTooltip();
                };
                sourceCopyImg.addEventListener('click', clickImg);
            }

            return tooltip;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // when tooltip is clicked
        function onTooltipClick(event) {
            // when user clicks on tooltip, stop click from transferring
            // outside of tooltip (eg, click off to close tooltip, or eg click
            // off to unhighlight same refs)
            event.stopPropagation();
        }

        // when tooltip is unhovered
        function onTooltipUnhover(event) {
            if (options.clickClose === 'true')
                return;

            // make sure new mouse/touch/focus no longer over tooltip or any
            // element within it
            const tooltip = document.getElementById('tooltip');
            if (!tooltip)
                return;
            if (this.contains(event.relatedTarget))
                return;

            closeTooltip();
        }

        // make nav bar to go betwen prev/next instances of same reference
        function makeNavBar(link) {
            // find other links to the same source
            const sameLinks = getSameLinks(link);

            // don't show nav bar when singular reference
            if (sameLinks.total <= 1)
                return;

            // find prev/next links with same target
            const prevLink = getPrevLink(link, sameLinks);
            const nextLink = getNextLink(link, sameLinks);

            // create nav bar
            const navBar = document.createElement('div');
            navBar.id = 'tooltip_nav_bar';
            const text = sameLinks.index + 1 + ' of ' + sameLinks.total;

            // create nav bar prev/next buttons
            const prevButton = document.createElement('button');
            const nextButton = document.createElement('button');
            prevButton.id = 'tooltip_prev_button';
            nextButton.id = 'tooltip_next_button';
            prevButton.title =
                'Jump to the previous occurence of this item in the document [←]';
            nextButton.title =
                'Jump to the next occurence of this item in the document [→]';
            prevButton.classList.add('icon_button');
            nextButton.classList.add('icon_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;
            navBar.appendChild(prevButton);
            navBar.appendChild(document.createTextNode(text));
            navBar.appendChild(nextButton);

            // attach click listeners to buttons
            prevButton.addEventListener('click', function() {
                onPrevNextClick(link, prevLink);
            });
            nextButton.addEventListener('click', function() {
                onPrevNextClick(link, nextLink);
            });

            return navBar;
        }

        // get previous link with same target
        function getPrevLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if < 1
            let index;
            if (sameLinks.index - 1 >= 0)
                index = sameLinks.index - 1;
            else
                index = sameLinks.total - 1;
            return sameLinks.elements[index];
        }

        // get next link with same target
        function getNextLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if > total
            let index;
            if (sameLinks.index + 1 <= sameLinks.total - 1)
                index = sameLinks.index + 1;
            else
                index = 0;
            return sameLinks.elements[index];
        }

        // get element that is target of link or url hash
        function getSource(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if ref or figure, modify target to get expected element
            if (id.indexOf('ref-') === 0)
                target = target.querySelector('p');
            else if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');

            return target;
        }

        // when prev/next arrow button is clicked
        function onPrevNextClick(link, prevNextLink) {
            if (link && prevNextLink)
                goToElement(prevNextLink, window.innerHeight * 0.5);
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // determine position to place tooltip based on link position in
        // viewport and tooltip size
        function positionTooltip(link, left, top) {
            const tooltipElement = document.getElementById('tooltip');
            if (!tooltipElement)
                return;

            // get convenient vars for position/dimensions of
            // link/tooltip/page/view
            link = getRectInPage(link);
            const tooltip = getRectInPage(tooltipElement);
            const view = getRectInPage();

            // horizontal positioning
            if (left)
                // use explicit value
                left = left;
            else if (link.left + tooltip.width < view.right)
                // fit tooltip to right of link
                left = link.left;
            else if (link.right - tooltip.width > view.left)
                // fit tooltip to left of link
                left = link.right - tooltip.width;
            // center tooltip in view
            else
                left = (view.right - view.left) / 2 - tooltip.width / 2;

            // vertical positioning
            if (top)
                // use explicit value
                top = top;
            else if (link.top - tooltip.height > view.top)
                // fit tooltip above link
                top = link.top - tooltip.height;
            else if (link.bottom + tooltip.height < view.bottom)
                // fit tooltip below link
                top = link.bottom;
            else {
                // center tooltip in view
                top = view.top + view.height / 2 - tooltip.height / 2;
                // nudge off of link to left/right if possible
                if (link.right + tooltip.width < view.right)
                    left = link.right;
                else if (link.left - tooltip.width > view.left)
                    left = link.left - tooltip.width;
            }

            tooltipElement.style.left = left + 'px';
            tooltipElement.style.top = top + 'px';
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get position of element relative to page
        function getRectInPage(element) {
            const rect = getRectInView(element);
            const body = getRectInView(document.body);

            const newRect = {};
            newRect.left = rect.left - body.left;
            newRect.top = rect.top - body.top;
            newRect.right = rect.right - body.left;
            newRect.bottom = rect.bottom - body.top;
            newRect.width = rect.width;
            newRect.height = rect.height;

            return newRect;
        }

        // (for interaction with accordion plugin)
        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // (for interaction with accordion plugin)
        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- jump to first plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds a button next to each reference entry,
        // figure, and table that jumps the page to the first occurrence of a
        // link to that item in the manuscript.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'jumpToFirst';

        // default plugin options
        const options = {
            // whether to add buttons next to reference entries
            references: 'true',
            // whether to add buttons next to figures
            figures: 'true',
            // whether to add buttons next to tables
            tables: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            if (options.references !== 'false')
                makeReferenceButtons();
            if (options.figures !== 'false')
                makeFigureButtons();
            if (options.tables !== 'false')
                makeTableButtons();
        }

        // when jump button clicked
        function onButtonClick() {
            const first = getFirstOccurrence(this.dataset.id);
            if (!first)
                return;

            // update url hash so navigating "back" in history will return
            // user to jump button
            window.location.hash = this.dataset.id;
            // scroll to link
            window.setTimeout(function() {
                goToElement(first, window.innerHeight * 0.5);
            }, 0);
        }

        // get first occurence of link to item in document
        function getFirstOccurrence(id) {
            let query = 'a';
            query += '[href="#' + id + '"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelector(query);
        }

        // add button next to each reference entry
        function makeReferenceButtons() {
            const references = document.querySelectorAll('div[id^="ref-"]');
            for (const reference of references) {
                // get reference id and element to add button to
                const id = reference.id;
                const container = reference.firstElementChild;
                const first = getFirstOccurrence(id);

                // if can't find link to reference, ignore
                if (!first)
                    continue;

                // make jump button
                let button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this reference in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.innerHTML = button.outerHTML + container.innerHTML;
                button = container.firstElementChild;
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeFigureButtons() {
            const figures = document.querySelectorAll('[id^="fig:"]');
            for (const figure of figures) {
                // get figure id and element to add button to
                const id = figure.id;
                const container = figure.querySelector('figcaption') || figure;
                const first = getFirstOccurrence(id);

                // if can't find link to figure, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this figure in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeTableButtons() {
            const tables = document.querySelectorAll('[id^="tbl:"]');
            for (const table of tables) {
                // get ref id and element to add button to
                const id = table.id;
                const container = table.querySelector('caption') || table;
                const first = getFirstOccurrence(id);

                // if can't find link to table, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this table in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle double up icon -->

<template class="icon_angle_double_up">
    <!-- modified from: https://fontawesome.com/icons/angle-double-up -->
    <svg width="16" height="16" viewBox="0 0 320 512">
        <path
            fill="currentColor"
            d="M177 255.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 351.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 425.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1zm-34-192L7 199.7c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l96.4-96.4 96.4 96.4c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9l-136-136c-9.2-9.4-24.4-9.4-33.8 0z"
        ></path>
    </svg>
</template>
<!-- link highlight plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user hovers or
        // focuses a link, other links that have the same target will be
        // highlighted. It also makes it such that when clicking a link, the
        // target of the link (eg reference, figure, table) is briefly
        // highlighted.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'linkHighlight';

        // default plugin options
        const options = {
            // whether to also highlight links that go to external urls
            externalLinks: 'false',
            // whether user must click off to unhighlight instead of just
            // un-hovering
            clickUnhighlight: 'false',
            // whether to also highlight links that are unique
            highlightUnique: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach mouse and focus listeners to link
                link.addEventListener('mouseenter', onLinkFocus);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('mouseleave', onLinkUnhover);
            }

            // attach click and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('hashchange', onHashChange);

            // run hash change on window load in case user has navigated
            // directly to hash
            onHashChange();
        }

        // when link is focused (tabbed to) or hovered
        function onLinkFocus() {
            highlight(this);
        }

        // when link is unhovered
        function onLinkUnhover() {
            if (options.clickUnhighlight !== 'true')
                unhighlightAll();
        }

        // when the mouse is clicked anywhere in window
        function onClick(event) {
            unhighlightAll();
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                glowElement(target);
        }

        // get element that is target of link or url hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            return target;
        }

        // start glow sequence on an element
        function glowElement(element) {
            const startGlow = function() {
                onGlowEnd();
                element.dataset.glow = 'true';
                element.addEventListener('animationend', onGlowEnd);
            };
            const onGlowEnd = function() {
                element.removeAttribute('data-glow');
                element.removeEventListener('animationend', onGlowEnd);
            };
            startGlow();
        }

        // highlight link and all others with same target
        function highlight(link) {
            // force unhighlight all to start fresh
            unhighlightAll();

            // get links with same target
            if (!link)
                return;
            const sameLinks = getSameLinks(link);

            // if link unique and option is off, exit and don't highlight
            if (sameLinks.length <= 1 && options.highlightUnique !== 'true')
                return;

            // highlight all same links, and "select" (special highlight) this
            // one
            for (const sameLink of sameLinks) {
                if (sameLink === link)
                    sameLink.setAttribute('data-selected', 'true');
                else
                    sameLink.setAttribute('data-highlighted', 'true');
            }
        }

        // unhighlight all links
        function unhighlightAll() {
            const links = getLinks();
            for (const link of links) {
                link.setAttribute('data-selected', 'false');
                link.setAttribute('data-highlighted', 'false');
            }
        }

        // get links with same target
        function getSameLinks(link) {
            const results = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    results.push(otherLink);
            }
            return results;
        }

        // get all links of types we wish to handle
        function getLinks() {
            let query = 'a';
            if (options.externalLinks !== 'true')
                query += '[href^="#"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelectorAll(query);
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- table of contents plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin provides a "table of contents" (toc) panel on
        // the side of the document that allows the user to conveniently
        // navigate between sections of the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tableOfContents';

        // default plugin options
        const options = {
            // which types of elements to add links for, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3',
            // whether default behavior is to be closed ('false'), open
            // ('true'), or only open when screen wide enough to fit panel
            // ('auto'). note: still always starts closed when page loads.
            open: 'auto',
            // if list item is more than this many characters, text will be
            // truncated
            charLimit: '50',
            // whether or not to show bullets next to each toc item
            bullets: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // make toc panel and populate with entries (links to document
            // sections)
            const panel = makePanel();
            if (!panel)
                return;
            makeEntries(panel);
            document.body.insertBefore(panel, document.body.firstChild);

            closePanel();

            // attach click, scroll, and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('scroll', onScroll);
            window.addEventListener('hashchange', onScroll);
            window.addEventListener('keyup', onKeyUp);
            onScroll();

            // add class to push document body down out of way of toc button
            document.body.classList.add('toc_body_nudge');
        }

        // determine if screen wide enough to fit toc panel
        function isSmallScreen() {
            // in default theme:
            // 816px = 8.5in = width of "page" (<body>) element
            // 260px = min width of toc panel (*2 for both sides of <body>)
            return window.innerWidth < 816 + 260 * 2;
        }

        // open/close panel based on option and screen size
        function openOrClosePanel() {
            if (
                options.open === 'true' ||
                (options.open === 'auto' && !isSmallScreen())
            )
                openPanel();
            else
                closePanel();
        }

        // when mouse is clicked anywhere in window
        function onClick() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                openOrClosePanel();
        }

        // when window is scrolled or hash changed
        function onScroll() {
            highlightViewed();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            // close on esc
            if (event.key === 'Escape')
                closePanel();
        }

        // find entry of currently viewed document section in toc and highlight
        function highlightViewed() {
            const firstId = getFirstInView(options.typesQuery);

            // get toc entries (links), unhighlight all, then highlight viewed
            const list = document.getElementById('toc_list');
            if (!firstId || !list)
                return;
            const links = list.querySelectorAll('a');
            for (const link of links)
                link.dataset.viewing = 'false';
            const link = list.querySelector('a[href="#' + firstId + '"]');
            if (!link)
                return;
            link.dataset.viewing = 'true';
        }

        // get first or previous toc listed element in top half of view
        function getFirstInView(query) {
            // get all elements matching query and with id
            const elements = document.querySelectorAll(query);
            const elementsWithIds = [];
            for (const element of elements) {
                if (element.id)
                    elementsWithIds.push(element);
            }


            // get first or previous element in top half of view
            for (let i = 0; i < elementsWithIds.length; i++) {
                const element = elementsWithIds[i];
                const prevElement = elementsWithIds[Math.max(0, i - 1)];
                if (element.getBoundingClientRect().top >= 0) {
                    if (
                        element.getBoundingClientRect().top <
                        window.innerHeight / 2
                    )
                        return element.id;
                    else
                        return prevElement.id;
                }
            }
        }

        // make panel
        function makePanel() {
            // create panel
            const panel = document.createElement('div');
            panel.id = 'toc_panel';
            if (options.bullets === 'true')
                panel.dataset.bullets = 'true';

            // create header
            const header = document.createElement('div');
            header.id = 'toc_header';

            // create toc button
            const button = document.createElement('button');
            button.id = 'toc_button';
            button.innerHTML = document.querySelector(
                '.icon_th_list'
            ).innerHTML;
            button.classList.add('icon_button');

            // create header text
            const text = document.createElement('h3');
            text.innerHTML = 'Table of Contents';

            // create container for toc list
            const list = document.createElement('div');
            list.id = 'toc_list';

            // attach click listeners
            panel.addEventListener('click', onPanelClick);
            header.addEventListener('click', onHeaderClick);
            button.addEventListener('click', onButtonClick);

            // attach elements
            header.appendChild(button);
            header.appendChild(text);
            panel.appendChild(header);
            panel.appendChild(list);

            return panel;
        }

        // create toc entries (links) to each element of the specified types
        function makeEntries(panel) {
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements) {
                // do not add link if element doesn't have assigned id
                if (!element.id)
                    continue;

                // create link/list item
                const link = document.createElement('a');
                link.classList.add('toc_link');
                switch (element.tagName.toLowerCase()) {
                    case 'h1':
                        link.dataset.level = '1';
                        break;
                    case 'h2':
                        link.dataset.level = '2';
                        break;
                    case 'h3':
                        link.dataset.level = '3';
                        break;
                    case 'h4':
                        link.dataset.level = '4';
                        break;
                }
                link.title = element.innerText;
                let text = element.innerText;
                if (text.length > options.charLimit)
                    text = text.slice(0, options.charLimit) + '...';
                link.innerHTML = text;
                link.href = '#' + element.id;
                link.addEventListener('click', onLinkClick);

                // attach link
                panel.querySelector('#toc_list').appendChild(link);
            }
        }

        // when panel is clicked
        function onPanelClick(event) {
            // stop click from propagating to window/document and closing panel
            event.stopPropagation();
        }

        // when header itself is clicked
        function onHeaderClick(event) {
            togglePanel();
        }

        // when button is clicked
        function onButtonClick(event) {
            togglePanel();
            // stop header underneath button from also being clicked
            event.stopPropagation();
        }

        // when link is clicked
        function onLinkClick() {
            openOrClosePanel();
        }

        // open panel if closed, close if opened
        function togglePanel() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                closePanel();
            else
                openPanel();
        }

        // open panel
        function openPanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'true';
        }

        // close panel
        function closePanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'false';
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- th list icon -->

<template class="icon_th_list">
    <!-- modified from: https://fontawesome.com/icons/th-list -->
    <svg width="16" height="16" viewBox="0 0 512 512" tabindex="-1">
        <path
            fill="currentColor"
            d="M96 96c0 26.51-21.49 48-48 48S0 122.51 0 96s21.49-48 48-48 48 21.49 48 48zM48 208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm0 160c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm96-236h352c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
            tabindex="-1"
        ></path>
    </svg>
</template>
<!-- lightbox plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user clicks on an
        // image, the image fills the screen and the user can pan/drag/zoom
        // the image and navigate between other images in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'lightbox';

        // default plugin options
        const options = {
            // list of possible zoom/scale factors
            zoomSteps:
                '0.1, 0.25, 0.333333, 0.5, 0.666666, 0.75, 1,' +
                '1.25, 1.5, 1.75, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8',
            // whether to fit image to view ('fit'), display at 100% and shrink
            // if necessary ('shrink'), or always display at 100% ('100')
            defaultZoom: 'fit',
            // whether to zoom in/out toward center of view ('true') or mouse
            // ('false')
            centerZoom: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <img> element
            const imgs = document.querySelectorAll('figure > img');
            let count = 1;
            for (const img of imgs) {
                img.classList.add('lightbox_document_img');
                img.dataset.number = count;
                img.dataset.total = imgs.length;
                img.addEventListener('click', openLightbox);
                count++;
            }

            // attach mouse and key listeners to window
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('keyup', onKeyUp);
        }

        // when mouse is moved anywhere in window
        function onWindowMouseMove(event) {
            window.mouseX = event.clientX;
            window.mouseY = event.clientY;
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'lightbox_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'lightbox_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeLightbox();
                    break;
            }
        }

        // open lightbox
        function openLightbox() {
            const lightbox = makeLightbox(this);
            if (!lightbox)
                return;

            blurBody(lightbox);
            document.body.appendChild(lightbox);
        }

        // make lightbox
        function makeLightbox(img) {
            // delete lightbox if it exists, start fresh
            closeLightbox();

            // create screen overlay containing lightbox
            const overlay = document.createElement('div');
            overlay.id = 'lightbox_overlay';

            // create image info boxes
            const numberInfo = document.createElement('div');
            const zoomInfo = document.createElement('div');
            numberInfo.id = 'lightbox_number_info';
            zoomInfo.id = 'lightbox_zoom_info';

            // create container for image
            const imageContainer = document.createElement('div');
            imageContainer.id = 'lightbox_image_container';
            const lightboxImg = makeLightboxImg(
                img,
                imageContainer,
                numberInfo,
                zoomInfo
            );
            imageContainer.appendChild(lightboxImg);

            // create bottom container for caption and navigation buttons
            const bottomContainer = document.createElement('div');
            bottomContainer.id = 'lightbox_bottom_container';
            const caption = makeCaption(img);
            const prevButton = makePrevButton(img);
            const nextButton = makeNextButton(img);
            bottomContainer.appendChild(prevButton);
            bottomContainer.appendChild(caption);
            bottomContainer.appendChild(nextButton);

            // attach top middle and bottom to overlay
            overlay.appendChild(numberInfo);
            overlay.appendChild(zoomInfo);
            overlay.appendChild(imageContainer);
            overlay.appendChild(bottomContainer);

            return overlay;
        }

        // make <img> object that is intuitively draggable and zoomable
        function makeLightboxImg(
            sourceImg,
            container,
            numberInfoBox,
            zoomInfoBox
        ) {
            // create copy of source <img>
            const img = sourceImg.cloneNode(true);
            img.classList.remove('lightbox_document_img');
            img.removeAttribute('id');
            img.removeAttribute('width');
            img.removeAttribute('height');
            img.style.position = 'unset';
            img.style.margin = '0';
            img.style.padding = '0';
            img.style.width = '';
            img.style.height = '';
            img.style.minWidth = '';
            img.style.minHeight = '';
            img.style.maxWidth = '';
            img.style.maxHeight = '';
            img.id = 'lightbox_img';

            // build sorted list of unique zoomSteps, always including a 100%
            let zoomSteps = [];
            const optionsZooms = options.zoomSteps.split(/[^0-9.]/);
            for (const optionZoom of optionsZooms) {
                const newZoom = parseFloat(optionZoom);
                if (newZoom && !zoomSteps.includes(newZoom))
                    zoomSteps.push(newZoom);
            }
            if (!zoomSteps.includes(1))
                zoomSteps.push(1);
            zoomSteps = zoomSteps.sort(function sortNumber(a, b) {
                return a - b;
            });

            // <img> object property variables
            let zoom = 1;
            let translateX = 0;
            let translateY = 0;
            let clickMouseX = undefined;
            let clickMouseY = undefined;
            let clickTranslateX = undefined;
            let clickTranslateY = undefined;

            updateNumberInfo();

            // update image numbers displayed in info box
            function updateNumberInfo() {
                numberInfoBox.innerHTML =
                    sourceImg.dataset.number + ' of ' + sourceImg.dataset.total;
            }

            // update zoom displayed in info box
            function updateZoomInfo() {
                let zoomInfo = zoom * 100;
                if (!Number.isInteger(zoomInfo))
                    zoomInfo = zoomInfo.toFixed(2);
                zoomInfoBox.innerHTML = zoomInfo + '%';
            }

            // move to closest zoom step above current zoom
            const zoomIn = function() {
                for (const zoomStep of zoomSteps) {
                    if (zoomStep > zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                updateTransform();
            };

            // move to closest zoom step above current zoom
            const zoomOut = function() {
                zoomSteps.reverse();
                for (const zoomStep of zoomSteps) {
                    if (zoomStep < zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                zoomSteps.reverse();

                updateTransform();
            };

            // update display of <img> based on scale/translate properties
            const updateTransform = function() {
                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                // get new width/height after scale
                const rect = img.getBoundingClientRect();
                // limit translate
                translateX = Math.max(translateX, -rect.width / 2);
                translateX = Math.min(translateX, rect.width / 2);
                translateY = Math.max(translateY, -rect.height / 2);
                translateY = Math.min(translateY, rect.height / 2);

                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                updateZoomInfo();
            };

            // fit <img> to container
            const fit = function() {
                // no x/y offset, 100% zoom by default
                translateX = 0;
                translateY = 0;
                zoom = 1;

                // widths of <img> and container
                const imgWidth = img.naturalWidth;
                const imgHeight = img.naturalHeight;
                const containerWidth = parseFloat(
                    window.getComputedStyle(container).width
                );
                const containerHeight = parseFloat(
                    window.getComputedStyle(container).height
                );

                // how much zooming is needed to fit <img> to container
                const xRatio = imgWidth / containerWidth;
                const yRatio = imgHeight / containerHeight;
                const maxRatio = Math.max(xRatio, yRatio);
                const newZoom = 1 / maxRatio;

                // fit <img> to container according to option
                if (options.defaultZoom === 'shrink') {
                    if (maxRatio > 1)
                        zoom = newZoom;
                } else if (options.defaultZoom === 'fit')
                    zoom = newZoom;

                updateTransform();
            };

            // when mouse wheel is rolled anywhere in container
            const onContainerWheel = function(event) {
                if (!event)
                    return;

                // let ctrl + mouse wheel to zoom behave as normal
                if (event.ctrlKey)
                    return;

                // prevent normal scroll behavior
                event.preventDefault();
                event.stopPropagation();

                // point around which to scale img
                const viewRect = container.getBoundingClientRect();
                const viewX = (viewRect.left + viewRect.right) / 2;
                const viewY = (viewRect.top + viewRect.bottom) / 2;
                const originX = options.centerZoom === 'true' ? viewX : mouseX;
                const originY = options.centerZoom === 'true' ? viewY : mouseY;

                // get point on image under origin
                const oldRect = img.getBoundingClientRect();
                const oldPercentX = (originX - oldRect.left) / oldRect.width;
                const oldPercentY = (originY - oldRect.top) / oldRect.height;

                // increment/decrement zoom
                if (event.deltaY < 0)
                    zoomIn();
                if (event.deltaY > 0)
                    zoomOut();

                // get offset between previous image point and origin
                const newRect = img.getBoundingClientRect();
                const offsetX =
                    originX - (newRect.left + newRect.width * oldPercentX);
                const offsetY =
                    originY - (newRect.top + newRect.height * oldPercentY);

                // translate image to keep image point under origin
                translateX += offsetX;
                translateY += offsetY;

                // perform translate
                updateTransform();
            };

            // when container is clicked
            function onContainerClick(event) {
                // if container itself is target of click, and not other
                // element above it
                if (event.target === this)
                    closeLightbox();
            }

            // when mouse button is pressed on image
            const onImageMouseDown = function(event) {
                // store original mouse position relative to image
                clickMouseX = window.mouseX;
                clickMouseY = window.mouseY;
                clickTranslateX = translateX;
                clickTranslateY = translateY;
                event.stopPropagation();
                event.preventDefault();
            };

            // when mouse button is released anywhere in window
            const onWindowMouseUp = function(event) {
                // reset original mouse position
                clickMouseX = undefined;
                clickMouseY = undefined;
                clickTranslateX = undefined;
                clickTranslateY = undefined;

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mouseup', onWindowMouseUp);
            };

            // when mouse is moved anywhere in window
            const onWindowMouseMove = function(event) {
                if (
                    clickMouseX === undefined ||
                    clickMouseY === undefined ||
                    clickTranslateX === undefined ||
                    clickTranslateY === undefined
                )
                    return;

                // offset image based on original and current mouse position
                translateX = clickTranslateX + window.mouseX - clickMouseX;
                translateY = clickTranslateY + window.mouseY - clickMouseY;
                updateTransform();
                event.preventDefault();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mousemove', onWindowMouseMove);
            };

            // when window is resized
            const onWindowResize = function(event) {
                fit();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('resize', onWindowResize);
            };

            // attach the necessary event listeners
            img.addEventListener('dblclick', fit);
            img.addEventListener('mousedown', onImageMouseDown);
            container.addEventListener('wheel', onContainerWheel);
            container.addEventListener('mousedown', onContainerClick);
            container.addEventListener('touchstart', onContainerClick);
            window.addEventListener('mouseup', onWindowMouseUp);
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('resize', onWindowResize);

            // run fit() after lightbox atttached to document and <img> Loaded
            // so needed container and img dimensions available
            img.addEventListener('load', fit);

            return img;
        }

        // make caption
        function makeCaption(img) {
            const caption = document.createElement('div');
            caption.id = 'lightbox_caption';
            const captionSource = img.nextElementSibling;
            if (captionSource.tagName.toLowerCase() === 'figcaption') {
                const captionCopy = makeCopy(captionSource);
                caption.innerHTML = captionCopy.innerHTML;
            }

            caption.addEventListener('touchstart', function(event) {
                event.stopPropagation();
            });

            return caption;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // make button to jump to previous image in document
        function makePrevButton(img) {
            const prevButton = document.createElement('button');
            prevButton.id = 'lightbox_prev_button';
            prevButton.title = 'Jump to the previous image in the document [←]';
            prevButton.classList.add('icon_button', 'lightbox_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;

            // attach click listeners to button
            prevButton.addEventListener('click', function() {
                getPrevImg(img).click();
            });

            return prevButton;
        }

        // make button to jump to next image in document
        function makeNextButton(img) {
            const nextButton = document.createElement('button');
            nextButton.id = 'lightbox_next_button';
            nextButton.title = 'Jump to the next image in the document [→]';
            nextButton.classList.add('icon_button', 'lightbox_button');
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;

            // attach click listeners to button
            nextButton.addEventListener('click', function() {
                getNextImg(img).click();
            });

            return nextButton;
        }

        // get previous image in document
        function getPrevImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if < 1
            if (index - 1 >= 0)
                index--;
            else
                index = imgs.length - 1;
            return imgs[index];
        }

        // get next image in document
        function getNextImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if > total
            if (index + 1 <= imgs.length - 1)
                index++;
            else
                index = 0;
            return imgs[index];
        }

        // close lightbox
        function closeLightbox() {
            focusBody();

            const lightbox = document.getElementById('lightbox_overlay');
            if (lightbox)
                lightbox.remove();
        }

        // make all elements behind lightbox non-focusable
        function blurBody(overlay) {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.tabIndex = -1;
            document.body.classList.add('body_no_scroll');
        }

        // make all elements focusable again
        function focusBody() {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.removeAttribute('tabIndex');
            document.body.classList.remove('body_no_scroll');
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- attributes plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows arbitrary HTML attributes to be attached
        // to (almost) any element. Place an HTML comment inside or next to the
        // desired element in the format <!-- $attribute="value" -->

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'attributes';

        // default plugin options
        const options = {
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // get list of comments in document
            const comments = findComments();

            for(const comment of comments)
                if (comment.parentElement)
                    addAttributes(
                        comment.parentElement,
                        comment.nodeValue.trim()
                    );
        }

        // add html attributes to specified element based on string of 
        // html attributes and values
        function addAttributes(element, text) {
            // regex's for finding attribute/value pairs in the format of
            // attribute="value" or attribute='value
            const regex2 = /\$([a-zA-Z\-]+)?=\"(.+?)\"/;
            const regex1 = /\$([a-zA-Z\-]+)?=\'(.+?)\'/;

            // loop through attribute/value pairs
            let match;
            while(match = text.match(regex2) || text.match(regex1)) {
                // get attribute and value from regex capture groups
                let attribute = match[1];
                let value = match[2];

                // remove from string
                text = text.substring(match.index + match[0].length);

                if (!attribute || !value)
                    break;

                // set attribute of parent element
                try {
                    element.setAttribute(attribute, value);
                } catch(error) {
                    console.log(error);
                }

                // special case for colspan
                if (attribute === 'colspan')
                    removeTableCells(element, value);
            }
        }

        // get list of comment elements in document
        function findComments() {
            const comments = [];

            // iterate over comment nodes in document
            function acceptNode(node) {
                return NodeFilter.FILTER_ACCEPT;
            }
            const iterator = document.createNodeIterator(
                document.body,
                NodeFilter.SHOW_COMMENT,
                acceptNode
            );
            let node;
            while(node = iterator.nextNode())
                comments.push(node);

            return comments;
        }

        // remove certain number of cells after specified cell
        function removeTableCells(cell, number) {
            number = parseInt(number);
            if (!number)
                return;

            // remove elements
            for(; number > 1; number--) {
                if (cell.nextElementSibling)
                    cell.nextElementSibling.remove();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- math plugin configuration -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        "CommonHTML": { linebreaks: { automatic: true } },
        "HTML-CSS": { linebreaks: { automatic: true } },
        "SVG": { linebreaks: { automatic: true } },
        "fast-preview": { disabled: true }
    });
</script>

<!-- math plugin -->

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'MathJax' allows the proper rendering of
    // math/equations written in LaTeX.

    // https://www.mathjax.org/
</script>
<!-- annotations plugin configuration -->

<script>
    window.hypothesisConfig = function() {
        return {
            branding: {
                accentColor: '#2196f3',
                appBackgroundColor: '#f8f8f8',
                ctaBackgroundColor: '#f8f8f8',
                ctaTextColor: '#000000',
                selectionFontFamily: 'Open Sans, Helvetica, sans serif',
                annotationFontFamily: 'Open Sans, Helvetica, sans serif'
            }
        };
    };
</script>

<!-- annotations plugin -->

<script src='https://hypothes.is/embed.js'>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'Hypothesis' allows public annotation of the
    // manuscript.

    // https://web.hypothes.is/
</script>
</body>
</html>
